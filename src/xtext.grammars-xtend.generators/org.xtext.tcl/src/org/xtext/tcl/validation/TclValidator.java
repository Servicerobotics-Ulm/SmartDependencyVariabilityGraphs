/*
 * generated by Xtext 2.27.0
 */
package org.xtext.tcl.validation;


import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import BbDvgTcl.AbstractTCB;
import BbDvgTcl.ActionInstruction;
import BbDvgTcl.BbnPackage;
import BbDvgTcl.CallSequence;
import BbDvgTcl.ElseIf;
import BbDvgTcl.ErrorRef;
import BbDvgTcl.EventActivation;
import BbDvgTcl.FunctionCall;
import BbDvgTcl.TclOneOf;
import BbDvgTcl.TclParallel;
import BbDvgTcl.Plan;
import BbDvgTcl.Rule;
import BbDvgTcl.SameSignatureTCBs;
import BbDvgTcl.TCB;
import BbDvgTcl.TCBCall;
import BbDvgTcl.Function;
import BbDvgTcl.InternalVariableScope;
import BbDvgTcl.IfInstruction;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class TclValidator extends AbstractTclValidator {
	
//	@Check
//	public void checkGreetingStartsWithCapital(TCB tcb) {
//		
//		if (!Character.isUpperCase(tcb.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					ClassicTCLPackage.Literals.TCB__NAME);
//		}
//	}
	
	@Check
	public void checkRuleConsistency(TCB tcb) {
		System.out.println("TCB: "+ tcb.getName());
		
		for (Rule r : tcb.getRule()) {
			System.out.println("CURRENT RULE: "+ r.getName());
			List<Boolean> foundErrorList = new ArrayList<>();
			BbDvgTcl.Error error = r.getError();
			if (tcb.getPlan() != null) {
				List<CallSequence> csl = tcb.getPlan().getCallsequence();
				foundErrorList.add(foundError(error, csl));
			}

			for (ActionInstruction ai : tcb.getActioninstruction()) {
				if (ai instanceof Plan) {
					List<CallSequence> csl = ((Plan) ai).getCallsequence();
					foundErrorList.add(foundError(error, csl));
				}
			}
			
			// other rules i != r reacting to different return messages may push childs that may finally return the error that r requires
			for (Rule i : tcb.getRule()) {
				System.out.println("CHECK OTHER RULES: "+ i.getName());
				if (r != i) {
					System.out.println("r != i");
					for (ActionInstruction ai : i.getActioninstruction()) {
						if (ai instanceof Plan) {
							List<CallSequence> csl = ((Plan) ai).getCallsequence();
							foundErrorList.add(foundError(error, csl));
						}		
						else if (ai instanceof FunctionCall) {
							System.out.println("Rule: "+ i.getName() + "is a function call");
							// TODO: Is the following true?
							// an arbitrary nested sequence of function calls may follow that do not impact the parent-child relationship
							// the first function that then has a plan is the direct child of the rule i that must return a message to which a rule that is parent of r must react
							foundErrorList.addAll(Function(((FunctionCall) ai).getFunction(), error));
						}
					}
				}
			}
			
			// Associated event handlers may also push childs that can return the rule
			for (ActionInstruction ai : tcb.getActioninstruction()) {
				if (ai instanceof EventActivation) {
					for (ActionInstruction ai2 : ((EventActivation) ai).getEventhandler().getActioninstruction()) {
						if (ai2 instanceof Plan) {
							List<CallSequence> csl = ((Plan) ai2).getCallsequence();
							foundErrorList.add(foundError(error, csl));
						}
					}
				}
			}
			
			System.out.println("FOR RULE: "+r.getName());
			System.out.println("=========> " + foundErrorList);
			
			if (!foundErrorList.contains(true)) {
				warning("Not all associated rules are returned from the childs",
						BbnPackage.Literals.BLOCK__NAME);				
			}	
		}
	}
	
	public List<Boolean> Function(Function f, BbDvgTcl.Error error) {
		List<Boolean> foundErrorList = new ArrayList<>();
		
		for (ActionInstruction i : f.getActioninstruction()) {
			if (i instanceof FunctionCall) {
				System.out.println("Again a function call");
				Function(((FunctionCall) i).getFunction(), error);
			}
			else if (i instanceof Plan) {
				System.out.println("Is a plan!!!!!");
				List<CallSequence> csl = ((Plan) i).getCallsequence();
				foundErrorList.add(foundError(error, csl));	
			}
		}
		return foundErrorList;
	}
	
	// For the call sequence of a plan
	// returns true if at least one time the required error is returned in the childs
	// returns false if the required error is NOT returned in the childs
	public boolean foundError(BbDvgTcl.Error error, List<CallSequence> csl) {
		
		for (CallSequence cs : csl) {
			if (cs instanceof TCBCall) {
				if (foundError(error, ((TCBCall) cs))) {
					return true;
				}
			}
			else if (cs instanceof TclOneOf) {
				for (TCBCall i : ((TclOneOf) cs).getTcbcall()) {
					if (foundError(error, i)) {
						return true;
					}
				}
			}
			else if (cs instanceof TclParallel) {
				for (TCBCall i : ((TclParallel) cs).getTcbcall()) {
					if (foundError(error, i)) {
						return true;
					}
				}			
			}
		}
		System.out.println("Plan does NOT return the error!");
		return false;
	}
	
	
	public boolean foundError(BbDvgTcl.Error error, TCBCall tcbc) { 
		List<Boolean> foundErrorList = new ArrayList<>();
		AbstractTCB atcb = tcbc.getAbstracttcb();
		System.out.println("CHILD TCB: " + atcb.getName());
		if (atcb instanceof TCB) {
			// for the actions of a tcb child
			EList<ActionInstruction> ail = ((TCB) atcb).getActioninstruction();
			foundErrorList.add(foundError(error, ail));
			
			// for the associated rules of a tcb
			for (Rule r : ((TCB) atcb).getRule()) {
				foundErrorList.add(foundError(error, r.getActioninstruction()));		
			}
		}
		else if (atcb instanceof SameSignatureTCBs) {
			for (TCB t : ((SameSignatureTCBs) atcb).getTcb()) {
				foundErrorList.add(foundError(error, t.getActioninstruction()));
			}
		}
		
		if (foundErrorList.contains(true)) {
			return true;
		}
		else {
			return false;
		}	
	}
	
	// for the actions of a tcb child
	public boolean foundError(BbDvgTcl.Error error, EList<ActionInstruction> ail) {
		List<Boolean> foundErrorList = new ArrayList<>();
		for (ActionInstruction ai : ail) {
			if (ai instanceof ErrorRef) {
				if (((ErrorRef) ai).getError() == error) {
					foundErrorList.add(true);
				}
			}
			else if (ai instanceof EventActivation) {
				foundErrorList.add(foundError(error, ((EventActivation) ai).getEventhandler().getActioninstruction()));
			}
			else if (ai instanceof InternalVariableScope) {
				foundErrorList.add(foundError(error, ((InternalVariableScope) ai).getActioninstruction()));
			}
			else if (ai instanceof IfInstruction) {
				
				foundErrorList.add(foundError(error, ((IfInstruction) ai).getIf().getActioninstruction()));
				for (ElseIf ei: ((IfInstruction) ai).getElseif()) {
					foundErrorList.add(foundError(error, (ei.getActioninstruction())));
				}
				if (((IfInstruction) ai).getElse() != null) {
					foundErrorList.add(foundError(error, ((IfInstruction) ai).getElse().getActioninstruction()));
				}
			}
		}
		if (foundErrorList.contains(true)) {
			return true;
		}
		else {
			return false;
		}
	}
}
