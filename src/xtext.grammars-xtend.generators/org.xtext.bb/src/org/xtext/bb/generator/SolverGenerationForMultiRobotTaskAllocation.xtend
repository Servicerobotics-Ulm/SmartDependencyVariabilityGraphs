/*
 * generated by Xtext 2.21.0
 */
package org.xtext.bb.generator

import java.util.Map
import java.util.HashMap
import org.eclipse.emf.ecore.EObject
import java.util.List
import java.util.ArrayList
import java.util.AbstractMap.SimpleEntry
import BbDvgTcl.DVG
import BbDvgTcl.RPRO
import BbDvgTcl.APRO
import BbDvgTcl.CONT
import BbDvgTcl.PTCC
import BbDvgTcl.AGGR
import BbDvgTcl.MAGR
import BbDvgTcl.InputWSMPort
import BbDvgTcl.TRAN
import BbDvgTcl.COMF
import BbDvgTcl.AbstractOutputPort
import BbDvgTcl.INIT
import BbDvgTcl.EquivalenceFork
import BbDvgTcl.ConditionalFork
import BbDvgTcl.InputPort
import BbDvgTcl.SAPRO
import BbDvgTcl.EPROD
import BbDvgTcl.Interface
import BbDvgTcl.DMAGR
import BbDvgTcl.BBContainer
import BbDvgTcl.FinalOperation

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
 
class SolverGenerationForMultiRobotTaskAllocation {
	
	StringBuilder INITIALIZATION_CODE
	StringBuilder LOCAL_RESOLUTION_CODE
	StringBuilder CALL_SEQUENCE_CODE
	
	Map<BbDvgTcl.Pattern,Boolean> IS_RESOLVED_MAP
	Map<BbDvgTcl.Pattern, List<String>> DEPENDENCY_MAP
		
	Map<String, Integer> PASSIVE_LOOKUP
	List<SimpleEntry<String, Integer>> PASSIVE_LOOKUP_LIST
	Map<String, Integer> ACTIVE
	Map<String, Integer> CONSTANT
	DynamicSolutionLinks dsl
	
	List<List<Integer>> allocationsListListNoDuplicates
	Map<Integer, List<BbDvgTcl.Pattern>> solutionDVGPattern
	
	Map<AbstractOutputPort, List<BbDvgTcl.Pattern>> solutionInitInstances
	
	boolean mom = false
	
	boolean finalOperationIsMax
	
	def Map<String, Integer> getActive() {
		return this.ACTIVE
	}
	
	def Map<String, Integer> getPassive() {
		return this.PASSIVE_LOOKUP
	}	
	
	Map<AbstractOutputPort, Integer> UNIQUE_RESOURCE_ID
	
	def String start(DVG dvg, List<List<Integer>> allocationsListListNoDuplicates, Map<Integer, List<BbDvgTcl.Pattern>> solutionDVGPattern, boolean mom) {
		
		println("SolverGenerationForMultiRobotTaskAllocation started!")
		
		this.allocationsListListNoDuplicates = allocationsListListNoDuplicates
		this.solutionDVGPattern = solutionDVGPattern 
		
		this.mom = mom
		
		this.solutionInitInstances = new HashMap<AbstractOutputPort, List<BbDvgTcl.Pattern>>()
		
		this.UNIQUE_RESOURCE_ID = new HashMap<AbstractOutputPort, Integer>()

		this.dsl = new DynamicSolutionLinks()
		
		this.PASSIVE_LOOKUP = new HashMap<String, Integer>()
		this.PASSIVE_LOOKUP_LIST = new ArrayList<SimpleEntry<String, Integer>>()
		this.ACTIVE = new HashMap<String, Integer>()
		this.CONSTANT = new HashMap<String, Integer>()
		
		this.INITIALIZATION_CODE = new StringBuilder()
		this.LOCAL_RESOLUTION_CODE = new StringBuilder()
		this.CALL_SEQUENCE_CODE = new StringBuilder()
		
		this.IS_RESOLVED_MAP = new HashMap<BbDvgTcl.Pattern,Boolean>()		
		this.DEPENDENCY_MAP	= new HashMap<BbDvgTcl.Pattern, List<String>>()
		
		this.finalOperationIsMax = Helpers.GetFinalOperationIsMax(dvg.finalOperation)
		
		determineAbsoluteDependencies(dvg)
		generate(dvg)
		
		System.out.println("---------")
		System.out.println("PASSIVE LOOKUP")
		for (i : this.PASSIVE_LOOKUP.entrySet) {
			System.out.println(i.key + " : "+i.value)
		}
		System.out.println("PASSIVE LOOKUP_LIST")
		for (i : this.PASSIVE_LOOKUP_LIST) {
			System.out.println(i.key + " : " + i.value)
		}
		System.out.println("ACTIVE")
		for (i : this.ACTIVE.entrySet) {
			System.out.println(i.key + " : " + i.value) 
		}
		System.out.println("---------")
		
		var String outputName
		if (dvg.outputName !== null) {
			if (dvg.outputName == "") {
				outputName = "null"
			}
			else {
				outputName = dvg.outputName
			}
		}
		else {
			outputName = "null"
		}
		
		return generateDVGSolverCode(dvg.name, outputName).toString()	
	}
	
	def determineAbsoluteDependencies(DVG dvg) {
		
		this.dsl.determineDMAGRReferences(dvg)
		
		for (i : dvg.pattern) {
			this.IS_RESOLVED_MAP.put(i, false)
		}
		
		for (i : dvg.pattern) {
			//if (!this.IS_RESOLVED_MAP.get(i)) {
				this.DEPENDENCY_MAP.put(i, getNext(i))
			//}
		}
		
		for (i : dvg.bbcontainer) {
			println("######################################### bb container")
			determineAbsoluteDependencies(i)
		}
	}
	
	def determineAbsoluteDependencies(BBContainer bbc) {
		
		for (i : bbc.pattern) {
			this.DEPENDENCY_MAP.put(i, getNext(i))
		}
		
		for (i : bbc.bbcontainer) {
			determineAbsoluteDependencies(i)
		}
	}
	
	def List<String> getNext(BbDvgTcl.Pattern lp) {
		
		var List<String> stringList = new ArrayList<String>()
		
		if (lp instanceof RPRO) {
			for (i : lp.ip) {
				if (i.outputport !== null) {
					stringList.add(i.outputport.name)
					var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
						if (lpr instanceof MAGR) {
							var AGGR la = Helpers.getAGGR(i.outputport)
							stringList.addAll(getNext(la, lpr.name))
						}
						else {
							stringList.addAll(getNext(lpr))
						}	
				}
				else {
					stringList.add(i.name)
				}
			}
		}
		
		else if (lp instanceof SAPRO) {
			for (i : lp.ip) {
				if (i.outputport !== null) {
					stringList.add(i.outputport.name)
					var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
						if (lpr instanceof MAGR) {
							var AGGR la = Helpers.getAGGR(i.outputport)
							stringList.addAll(getNext(la, lpr.name))
						}
						else {
							stringList.addAll(getNext(lpr))
						}	
				}
				else {
					stringList.add(i.name)
				}
			}
		}		
		
		else if (lp instanceof APRO) {
			for (i : lp.ip) {
				if (i.outputport !== null) {
					stringList.add(i.outputport.name)
					var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
						if (lpr instanceof MAGR) {
							var AGGR la = Helpers.getAGGR(i.outputport)
							stringList.addAll(getNext(la, lpr.name))
						}					
						else {
							stringList.addAll(getNext(lpr))
						}
				}
				else {
					stringList.add(i.name)
				}
			}
		}
		
		else if (lp instanceof MAGR) {
			for (i : lp.aggr) {
				for (j : i.ip) {
					if (j.outputport !== null) {
						stringList.add(j.outputport.name)
						var BbDvgTcl.Pattern lpr = Helpers.getPattern(j.outputport)
							if (lpr instanceof MAGR) {
								var AGGR la = Helpers.getAGGR(j.outputport)
								stringList.addAll(getNext(la, lpr.name))
							}
							else {
								stringList.addAll(getNext(lpr))
							}	
					}
					else {
						stringList.add(j.name)
					}
				}
			}
		}
		 
		else if (lp instanceof CONT) {
			for (i : lp.ip) {
				if (i.outputport !== null) {
					stringList.add(i.outputport.name)
					var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
						if (lpr instanceof MAGR) {
							var AGGR la = Helpers.getAGGR(i.outputport)
							stringList.addAll(getNext(la, lpr.name))
						}
						else {
							stringList.addAll(getNext(lpr))
						}
				}
				else {
					stringList.add(i.name)
				}
			}
			
			var EObject tmp = lp.ipp
			if (tmp instanceof InputWSMPort) {
				stringList.add(tmp.outputwsmport.name)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(tmp.outputwsmport)
				stringList.addAll(getNext(lpr))
			}
			
		}
		
		else if (lp instanceof EPROD) {
			for (i : lp.ip) {
				if (i.outputport !== null) {
					stringList.add(i.outputport.name)
					var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
						if (lpr instanceof MAGR) {
							var AGGR la = Helpers.getAGGR(i.outputport)
							stringList.addAll(getNext(la, lpr.name))
						}
						else {
							stringList.addAll(getNext(lpr))
						}
				}
				else {
					stringList.add(i.name)
				}
			}
		}		
		
		else if (lp instanceof TRAN) {
			if (lp.ip.outputport !== null) {
				stringList.add(lp.ip.outputport.name)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(lp.ip.outputport)
					if (lpr instanceof MAGR) {
						var AGGR la = Helpers.getAGGR(lp.ip.outputport)
						stringList.addAll(getNext(la, lpr.name))
					}
					else {
						stringList.addAll(getNext(lpr))
					}	
			}
			else {
				stringList.add(lp.ip.name)
			}
		}
		
		else if (lp instanceof COMF) {
			if (lp.ip.outputport !== null) {
				stringList.add(lp.ip.outputport.name)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(lp.ip.outputport)
					if (lpr instanceof MAGR) {
						var AGGR la = Helpers.getAGGR(lp.ip.outputport)
						stringList.addAll(getNext(la, lpr.name))
					}
					else {
						stringList.addAll(getNext(lpr))
					}
			}
			else {
				stringList.add(lp.ip.outputport.name)
			}
			
			stringList.add(lp.icp.outputcport.name)
			var BbDvgTcl.Pattern lpr = Helpers.getPattern(lp.icp.outputcport)
			stringList.addAll(getNext(lpr))
		}
		
		else if (lp instanceof PTCC) {
			for (i : lp.ip) {
				if (i.outputport !== null) {
					stringList.add(i.outputport.name)
					var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
						if (lpr instanceof MAGR) {
							var AGGR la = Helpers.getAGGR(i.outputport)
							stringList.addAll(getNext(la, lpr.name))
						}
						else {
							stringList.addAll(getNext(lpr))
						}
				}
				else {
					stringList.add(i.name)
				}
			}
			
			var EObject tmp = lp.ipp
			if (tmp instanceof InputWSMPort) {
				stringList.add(tmp.outputwsmport.name)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(tmp.outputwsmport)
				stringList.addAll(getNext(lpr))
			}
		}
		
		this.IS_RESOLVED_MAP.put(lp, true)
		
		return stringList
	}
	
	def List<String> getNext(AGGR a, String pname) {
		var List<String> stringList = new ArrayList<String>()
		stringList.add(pname)
		for (i : a.ip) {
			if (i.outputport !== null) {
				stringList.add(i.outputport.name)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				if (lpr instanceof MAGR) {
					var AGGR la = Helpers.getAGGR(i.outputport)
					stringList.addAll(getNext(la, lpr.name))
				}
				else {
					stringList.addAll(getNext(lpr))
				}
			}
			else {
				stringList.add(i.name)
			}
		}
		return stringList
	}		
	
	def generate(DVG dvg) {
		
		for (i : this.IS_RESOLVED_MAP.entrySet) {
			i.value = false
		}

		for (i : dvg.pattern) {
			if (!this.IS_RESOLVED_MAP.get(i)) {
				resolveNext(i)
			}
		}
	}


	def String getInstanceName(BbDvgTcl.Pattern lp) {

		if (lp instanceof INIT) {

			var int instanceCounter = this.solutionInitInstances.get(lp.ainip).size()
			var String name = lp.ainip.name
			name = name+"_"+instanceCounter.toString()
			return name			
		}
	}

	def resolveNext(BbDvgTcl.Pattern lp) {
				
		var List<BbDvgTcl.DVGPort> inputSet = new ArrayList<BbDvgTcl.DVGPort>() // This is for generating the call sequence code of the patterns with the name of the referenced output node
		var List<List<BbDvgTcl.DVGPort>> inputSetAg = new ArrayList<List<BbDvgTcl.DVGPort>>()
		var List<BbDvgTcl.AbstractInputPort> inputSetInputs = new ArrayList<BbDvgTcl.AbstractInputPort>() // This is for the $names$ in the expressions
		var List<List<SimpleEntry<AbstractOutputPort,String>>> allocInputSet = new ArrayList<List<SimpleEntry<AbstractOutputPort,String>>>()
		var List<Boolean> isAlloc = new ArrayList<Boolean>()
		
		if (lp instanceof INIT) {
			
			if (lp.ainip.interface === null) {
				this.INITIALIZATION_CODE.append(Leafs.generateLeaf(lp.ainip))
			}
			else if (lp.ainip.interface !== null && lp.ainip.interface == Interface.INTERNAL) {
				this.INITIALIZATION_CODE.append(Leafs.generateLeaf(lp.ainip))
			}
			else if (lp.ainip.interface !== null && lp.ainip.interface == Interface.EXTERNAL) {

				var String res = ""
				if (Helpers.isComplexDo(lp.ainip.ve)) {
					res += Leafs.generateLeafValuesComplexTcl(lp.ainip.name)
				}
				else {
					res += Leafs.generateLeafValuesTcl(lp.ainip.name)
				}
				
				this.INITIALIZATION_CODE.append(res)
			}
					
			addVariationPoints(lp)
		}
				
		else if (lp instanceof RPRO) {
			for (i : lp.ip) {
				inputSetInputs.add(i)
				inputSet.add(i.outputport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
		}
		
		else if (lp instanceof SAPRO) {
			for (i : lp.ip) {
				inputSetInputs.add(i)
				inputSet.add(i.outputport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
		}		
		
		else if (lp instanceof APRO) {  
			for (i : lp.ip) {
			
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				inputSetInputs.add(i)
				
				if (lpr instanceof DMAGR) {	// TODO: Should be handled for other patterns as well?
					// TODO: We need to handle the case where NOT all input ports of a pattern depend on a DMAGR
					handleDMAGRDep(lp, i, allocInputSet, isAlloc)
				}
				else {
					
					inputSet.add(i.outputport)
					isAlloc.add(false)
					
					if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
						this.IS_RESOLVED_MAP.put(lpr,false)
						resolveNext(lpr)
					}
					else {
						if (!this.IS_RESOLVED_MAP.get(lpr)) {
							resolveNext(lpr)
						}
					}
				}
			}
		}
		
		else if (lp instanceof MAGR) { 
			
			if (lp.f !== null) {
				if (lp.f instanceof EquivalenceFork) {
					this.ACTIVE.put(lp.name, lp.aggr.get(0).ip.size)
				}
				else if (lp.f instanceof ConditionalFork) {
					this.PASSIVE_LOOKUP.put(lp.name, lp.aggr.get(0).ip.size)
					this.PASSIVE_LOOKUP_LIST.add(new SimpleEntry<String, Integer>(lp.name, lp.aggr.get(0).ip.size)) 
				}	
			}
			
			else if (lp.o !== null) {
				this.ACTIVE.put(lp.name, lp.aggr.get(0).ip.size)
			}
			else if (lp.or !== null) {
				this.ACTIVE.put(lp.name, lp.aggr.get(0).ip.size)
			}
			else if (lp.x !== null) {
				this.ACTIVE.put(lp.name, lp.aggr.get(0).ip.size)
			}						
			
			for (i : lp.aggr) {
				var List<BbDvgTcl.DVGPort> tmp = new ArrayList<BbDvgTcl.DVGPort>()
				for (j : i.ip) {
					inputSetInputs.add(j)
					tmp.add(j.outputport)
					var BbDvgTcl.Pattern lpr = Helpers.getPattern(j.outputport)
					
					if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
						this.IS_RESOLVED_MAP.put(lpr,false)
						resolveNext(lpr)
					}
					else {
						if (!this.IS_RESOLVED_MAP.get(lpr)) {
							resolveNext(lpr)
						}
					}
				}
				inputSetAg.add(tmp)
			}
			
		}
		
		else if (lp instanceof DMAGR) {
			// Do nothing: We handle DMAGR for patterns that depend on DMAGR			
		}
		
		else if (lp instanceof CONT) {
			for (i : lp.ip) {
				inputSetInputs.add(i)
				inputSet.add(i.outputport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
			
			var EObject tmp = lp.ipp
			if (tmp instanceof InputWSMPort) {
				inputSetInputs.add(tmp)
				inputSet.add(tmp.outputwsmport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(tmp.outputwsmport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
		}
		
		else if (lp instanceof EPROD) {
			for (i : lp.ip) {
				inputSetInputs.add(i)
				inputSet.add(i.outputport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
		}		
		
		else if (lp instanceof TRAN) {
			inputSetInputs.add(lp.ip)
			inputSet.add(lp.ip.outputport)
			var BbDvgTcl.Pattern lpr = Helpers.getPattern(lp.ip.outputport)
			
			if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
				this.IS_RESOLVED_MAP.put(lpr,false)
				resolveNext(lpr)
			}
			else {
				if (!this.IS_RESOLVED_MAP.get(lpr)) {
					resolveNext(lpr)
				}
			}
		}
		
		else if (lp instanceof COMF) {
			inputSetInputs.add(lp.ip)
			var BbDvgTcl.Pattern lpr = Helpers.getPattern(lp.ip.outputport)
			
			if (lpr instanceof DMAGR) {	// TODO: Should be handled for other patterns as well?
				handleDMAGRDep(lp, lp.ip, allocInputSet, isAlloc)
				
				// We assume that icps are not linked to DMAGRs
				inputSetInputs.add(lp.icp)
				inputSet.add(lp.icp.outputcport)
				isAlloc.add(false)
				
				lpr = Helpers.getPattern(lp.icp.outputcport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}						
			}
			else {
				inputSet.add(lp.ip.outputport)
				isAlloc.add(false)
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
				
				inputSetInputs.add(lp.icp)
				inputSet.add(lp.icp.outputcport)
				lpr = Helpers.getPattern(lp.icp.outputcport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}	
			}
			
		}
		
		else if (lp instanceof PTCC) {
			for (i : lp.ip) {
				inputSetInputs.add(i)
				inputSet.add(i.outputport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
			
			var EObject tmp = lp.ipp
			if (tmp instanceof InputWSMPort) {
				inputSetInputs.add(tmp)
				inputSet.add(tmp.outputwsmport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(tmp.outputwsmport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
			
		}
		
		// all dependencies of lp are already resolved/generated
		// call this function with name(list of inputs) where the inputs are instances of nodes with assigned vsps
		resolve(lp, inputSetInputs)
		this.IS_RESOLVED_MAP.put(lp, true)
		if (lp instanceof MAGR) {
			this.CALL_SEQUENCE_CODE.append(JavaFunctions.generateCallSequenceCodeAg(lp.name, inputSetAg))
		}
		else if (!(lp instanceof INIT) && !(lp instanceof DMAGR)) {
			this.CALL_SEQUENCE_CODE.append(JavaFunctions.generateCallSequenceCode(lp.name, inputSet, allocInputSet, isAlloc))
		}
	}
	
	def handleDMAGRDep(BbDvgTcl.Pattern lp, InputPort i, List<List<SimpleEntry<AbstractOutputPort,String>>> allocInputSet, List<Boolean> isAlloc) {

		var List<SimpleEntry<AbstractOutputPort, String>> ais = getMatchingSolutionOutputForEachAllocation(lp, i)
		
		println("Depends on DMAGR: " +lp.name)
		
		for (f : ais) {
			println(f.key.name)
		}
		allocInputSet.add(ais)
		isAlloc.add(true)

		for (a : ais) {
			var BbDvgTcl.Pattern lpr = Helpers.getPattern(a.key)
			
			if (lpr instanceof INIT) {

				if (!this.solutionInitInstances.containsKey(a.key)) {
					
					var List<BbDvgTcl.Pattern> tmp = new ArrayList<BbDvgTcl.Pattern>()
					tmp.add(lp)
					this.solutionInitInstances.put(a.key, tmp)
					var String n = getInstanceName(lpr)
					a.value = n

					if (lpr.ainip.interface === null || (lpr.ainip.interface !== null && lpr.ainip.interface == Interface.INTERNAL)) {
						if (this.mom) {
							this.INITIALIZATION_CODE.append(Leafs.generateLeaf(lpr.ainip, n, this.UNIQUE_RESOURCE_ID.get(lpr.ainip)))
						}
						else {
							this.INITIALIZATION_CODE.append(Leafs.generateLeaf(lpr.ainip, n))
						}
					}								
				}
				else {
					var List<BbDvgTcl.Pattern> tmp = this.solutionInitInstances.get(a.key)
					if (!tmp.contains(lp)) {
						tmp.add(lp)
						this.solutionInitInstances.put(a.key, tmp)
						var String n = getInstanceName(lpr)
						a.value = n

						if (lpr.ainip.interface === null || (lpr.ainip.interface !== null && lpr.ainip.interface == Interface.INTERNAL)) {
							if (this.mom) {
								this.INITIALIZATION_CODE.append(Leafs.generateLeaf(lpr.ainip, n, this.UNIQUE_RESOURCE_ID.get(lpr.ainip)))
							}
							else {
								this.INITIALIZATION_CODE.append(Leafs.generateLeaf(lpr.ainip, n))
							}
						}								
					}
					else {
						// The case for several allocations of the same input of the same pattern
						// we should still assign the corresponding instance name
						var String n = getInstanceName(lpr)
						a.value = n
					}
				}
				
				addVariationPoints(lpr)
			}
			else {
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}	
			}						
		}	
	}

	def List<SimpleEntry<AbstractOutputPort,String>> getMatchingSolutionOutputForEachAllocation(BbDvgTcl.Pattern p, InputPort ip) {
		// For every allocation: We need to link it to a matching output of a solution of the current allocation

		var List<SimpleEntry<AbstractOutputPort,String>> solutionOutputAllocations = new ArrayList<SimpleEntry<AbstractOutputPort,String>>()
		for (var int j = 0; j < this.allocationsListListNoDuplicates.size(); j++) {

			var int solution = -1;
			
			if (this.allocationsListListNoDuplicates.get(0).size == 1) {
				// There are no resource groups modeled, index is therefore 0
				solution = this.allocationsListListNoDuplicates.get(j).get(0)
			}
			else {
				solution = this.allocationsListListNoDuplicates.get(j).get(Helpers.getResGroupOfPattern(p))
			}
			// solution for j-th allocation variant and k-th resource group
			var List<BbDvgTcl.Pattern> solutionPatterns = solutionDVGPattern.get(solution);
			
			for (m : solutionPatterns) {
				if (ip.outputport.ve == Helpers.getVeFromPattern(m)) {
					// m is the matching solution pattern of i-th input of current pattern (APRO) of j-th allocation and k-th resource group 
					if (m instanceof INIT) {
						solutionOutputAllocations.add(new SimpleEntry(m.ainip, m.ainip.name))
						println("m.ainip: "+ m.ainip.name)
						
						this.UNIQUE_RESOURCE_ID.put(m.ainip, solution)
					}
				}
			}
		}
		return solutionOutputAllocations
	}

	
	def resolve(BbDvgTcl.Pattern lp, List<BbDvgTcl.AbstractInputPort> inputSet) {
		
		// If we are here to rlve/generate lp all its dependencies/VSPs are already resolved/generated
		
		//System.out.println("+++++++++++++++++++++++++++++++++ RESOLVE "+ lp.name+"+++++++++++++++++++++++++++++++++++++++++++++++")
		
		if (lp instanceof COMF) { 
			var COMFPattern comfp = new COMFPattern(lp)
			comfp.generate()
			this.LOCAL_RESOLUTION_CODE.append(comfp.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")
		}
		
		else if (lp instanceof RPRO) {
			var RPROPattern rprop
			if (lp.opp !== null && lp.op !== null) {
				System.out.println("ERROR: RPRO can not have both a OutputNode and a OutputPSNode!")
			}
			else if (lp.opp !== null && lp.op === null) {
				rprop = new RPROPattern(lp, inputSet, true)
				rprop.generate()
				this.LOCAL_RESOLUTION_CODE.append(rprop.getCode())
				this.LOCAL_RESOLUTION_CODE.append("\n\n")
			}
			else if (lp.opp === null && lp.op !== null) {
				rprop = new RPROPattern(lp, inputSet, false)
				rprop.generate()
				this.LOCAL_RESOLUTION_CODE.append(rprop.getCode())
				this.LOCAL_RESOLUTION_CODE.append("\n\n")
			}
			else {
				System.out.println("ERROR: RPRO has no OutputNode!")
			}
		}
		
		else if (lp instanceof SAPRO) {
			var SAPROPattern saprop = new SAPROPattern(lp, inputSet)
			saprop.generate()
			this.LOCAL_RESOLUTION_CODE.append(saprop.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")
		}
		
		else if (lp instanceof APRO) { 
			var APROPattern aprop = new APROPattern(lp, inputSet, true)
			aprop.generate()
			this.LOCAL_RESOLUTION_CODE.append(aprop.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")
		}
		
		else if (lp instanceof MAGR) {
			var MAGRPattern magrp = new MAGRPattern(lp)
			magrp.generate()
			this.LOCAL_RESOLUTION_CODE.append(magrp.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")			
		}
		
		else if (lp instanceof TRAN) {
			var TRANPattern tranp = new TRANPattern(lp)
			tranp.generate()
			this.LOCAL_RESOLUTION_CODE.append(tranp.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")
		}
		
		else if (lp instanceof CONT) {
			var CONTPattern contp = new CONTPattern(lp)
			contp.generate()
			this.LOCAL_RESOLUTION_CODE.append(contp.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")			
		}
		
		else if (lp instanceof EPROD) {
			var EPRODPattern eprop = new EPRODPattern(lp)
			eprop.generate()
			this.LOCAL_RESOLUTION_CODE.append(eprop.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")	
		}
		
		else if (lp instanceof PTCC) {
			var PTCCPattern ptccp = new PTCCPattern(lp)
			ptccp.generate()
			this.LOCAL_RESOLUTION_CODE.append(ptccp.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")				
		}
		
		else {
			//System.out.println("ERROR: Unknown Local Pattern!")
		}
	}
	
	def addVariationPoints(INIT init) {
		if (init.ainip.vt == BbDvgTcl.VT.ACTIVE) {
			this.ACTIVE.put(init.ainip.name, Helpers.getVSPInitSize(init.ainip))
		}
		else if (init.ainip.vt == BbDvgTcl.VT.CONSTANT) {
			this.CONSTANT.put(init.ainip.name, Helpers.getVSPInitSize(init.ainip))
		}
		else {
			this.PASSIVE_LOOKUP.put(init.ainip.name, Helpers.getVSPInitSize(init.ainip))
			this.PASSIVE_LOOKUP_LIST.add(new SimpleEntry<String, Integer>(init.ainip.name, Helpers.getVSPInitSize(init.ainip)))
		}		
	}
	
	def generateInitCode() {
		'''
		void init() {
			this.NODE_COLLECTION = new HashMap<String, Node>();
			List<Object> leafValues;
			List<List<Object>> leafValues_2;
			List<Map<String,Double>> leafValuesPsMapList;
			Map<String,Double> leafValuesPsMap;
			NodeObject nodeObject;
			NodeObjectList nodeObjectList;
			NodePs nodePs;
			Random random;
			String[] dataFromFile;
		
			«this.INITIALIZATION_CODE»
		}
		'''
	}
	
	def generateDVGSolverCode(String dvgName, String outputName) {
		'''
		«generateSolveCode(dvgName, outputName)»
		«IF !this.mom»
			public class DVGSolver_«dvgName» {
				public static void main (String[] args) {
					Solve solve = new Solve();
					solve.init();
					solve.solve();	
				}
			}
		«ENDIF»
		'''
	}
	
	def generateSolveCode(String dvgName, String outputName) {
		'''
		«IF !this.mom»
			class Solve {
		«ELSE»
			class «dvgName» {
				Node getNode(String name) {
					return NODE_COLLECTION.get(name);
				}
				int getAllocations() {
					return «this.allocationsListListNoDuplicates.size()»;
				}
		«ENDIF»
			private Map<String, Node> NODE_COLLECTION;
			
			«JavaFunctions.generateGetCartesianProduct»
			«JavaFunctions.generateIsSAM»
			«JavaFunctions.generateIsValidCombinationIgnoreResource»
			«JavaFunctions.generateIsDominated»
			«JavaFunctions.generateMaxFunction»
			«JavaFunctions.generateMinFunction»
			«JavaFunctions.generateGetDataFromFile»
			«this.LOCAL_RESOLUTION_CODE»
			«generateInitCode»
			
			«IF !this.mom»
				«FinalEvaluation.generateSolveCode(outputName, this.finalOperationIsMax, this.CALL_SEQUENCE_CODE.toString, this.ACTIVE, this.PASSIVE_LOOKUP, this.allocationsListListNoDuplicates.size())»
			«ELSE»
				Node solve(String name, int allocation) {
					List<Node> params;
					List<List<Node>> params_2d;
					«this.CALL_SEQUENCE_CODE»
					return this.NODE_COLLECTION.get(name);
				}
			«ENDIF»
		}
		'''
	}	
	
}
