/*
 * generated by Xtext 2.21.0
 */
package org.xtext.bb.generator

import java.util.Map
import java.util.HashMap
import org.eclipse.emf.ecore.EObject
import java.util.List
import java.util.ArrayList
import java.util.AbstractMap.SimpleEntry
import BbDvgTcl.DVG
import BbDvgTcl.RPRO
import BbDvgTcl.APRO
import BbDvgTcl.CONT
import BbDvgTcl.PTCC
import BbDvgTcl.MAGR
import BbDvgTcl.InputWSMPort
import BbDvgTcl.TRAN
import BbDvgTcl.COMF
import BbDvgTcl.INIT
import BbDvgTcl.EquivalenceFork
import BbDvgTcl.ConditionalFork
import BbDvgTcl.SAPRO
import BbDvgTcl.EPROD
import BbDvgTcl.Interface
import BbDvgTcl.FinalOperation

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
 
class SolverGenerationForSingleRobotWithFixedAllocation /*extends AbstractGenerator*/ {
	
	StringBuilder INITIALIZATION_CODE
	StringBuilder LOCAL_RESOLUTION_CODE
	StringBuilder CALL_SEQUENCE_CODE
	
	Map<BbDvgTcl.Pattern,Boolean> IS_RESOLVED_MAP
		
	Map<String, Integer> PASSIVE_LOOKUP
	List<SimpleEntry<String, Integer>> PASSIVE_LOOKUP_LIST
	Map<String, Integer> ACTIVE
	Map<String, String> ACTIVE_BBNAME
	Map<String, Integer> ACTIVE_IINDEX
	Map<String, String> ACTIVE_VE
	Map<String, Integer> CONSTANT
	
	boolean finalOperationIsMax
		
	//override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
	def String getDVGSolverCode(DVG dvg) {
		
		println("SolverGenerationForSingleRobotWithFixedAllocation started!")
		
		this.PASSIVE_LOOKUP = new HashMap<String, Integer>()
		this.PASSIVE_LOOKUP_LIST = new ArrayList<SimpleEntry<String, Integer>>()
		this.ACTIVE = new HashMap<String, Integer>()
		this.ACTIVE_BBNAME = new HashMap<String, String>()
		this.ACTIVE_IINDEX = new HashMap<String, Integer>()
		this.ACTIVE_VE = new HashMap<String, String>()
		this.CONSTANT = new HashMap<String, Integer>()

		this.INITIALIZATION_CODE = new StringBuilder()
		this.LOCAL_RESOLUTION_CODE = new StringBuilder()
		this.CALL_SEQUENCE_CODE = new StringBuilder()
		
		this.IS_RESOLVED_MAP = new HashMap<BbDvgTcl.Pattern,Boolean>()		
		
		this.finalOperationIsMax = Helpers.GetFinalOperationIsMax(dvg.finalOperation)
		
		generate(dvg)
		
		println("---------")
		println("PASSIVE LOOKUP")
		for (i : this.PASSIVE_LOOKUP.entrySet) {
			println(i.key + " : "+i.value)
		}
		println("PASSIVE LOOKUP_LIST")
		for (i : this.PASSIVE_LOOKUP_LIST) {
			println(i.key + " : " + i.value)
		}
		println("ACTIVE")
		for (i : this.ACTIVE.entrySet) {
			println(i.key + " : " + i.value)
		}
		println("---------")
			
		var String outputName
		if (dvg.outputName !== null) {
			if (dvg.outputName == "") {
				outputName = "null"
			}
			else {
				outputName = dvg.outputName
			}
		}
		else {
			outputName = "null"
		}
		
		return generateDVGSolverCode(dvg.name, outputName).toString
	}
	
	def generate(DVG dvg) {
		
		this.IS_RESOLVED_MAP = new HashMap<BbDvgTcl.Pattern,Boolean>()
		
		for (i : dvg.pattern) {
			this.IS_RESOLVED_MAP.put(i, false)
		}
		
		for (i : dvg.pattern) {
			if (!this.IS_RESOLVED_MAP.get(i)) {
				resolveNext(i)
			}
		}
	}
	
	def resolveNext(BbDvgTcl.Pattern lp) {
		
		var List<BbDvgTcl.DVGPort> inputSet = new ArrayList<BbDvgTcl.DVGPort>() // This is for generating the call sequence code of the patterns with the name of the referenced output node
		var List<List<BbDvgTcl.DVGPort>> inputSetAg = new ArrayList<List<BbDvgTcl.DVGPort>>()
		var List<BbDvgTcl.AbstractInputPort> inputSetInputs = new ArrayList<BbDvgTcl.AbstractInputPort>() // This is for the $names$ in the expressions
		
		if (lp instanceof INIT) {
			
			if (lp.ainip.interface === null) {
				this.INITIALIZATION_CODE.append(Leafs.generateLeaf(lp.ainip))
			}
			else if (lp.ainip.interface !== null && lp.ainip.interface == Interface.INTERNAL) {
				this.INITIALIZATION_CODE.append(Leafs.generateLeaf(lp.ainip))
			}
			else if (lp.ainip.interface !== null && lp.ainip.interface == Interface.EXTERNAL) {
				
				var String res = ""
				if (Helpers.isComplexDo(lp.ainip.ve)) {
					res += Leafs.generateLeafValuesComplexTcl(lp.ainip.name)
				}
				else {
					res += Leafs.generateLeafValuesTcl(lp.ainip.name)
				}
				
				this.INITIALIZATION_CODE.append(res)
			}
			
			if (lp.ainip.vt == BbDvgTcl.VT.ACTIVE) {
				this.ACTIVE.put(lp.ainip.name, Helpers.getVSPInitSize(lp.ainip))
				this.ACTIVE_BBNAME.put(lp.ainip.name, Helpers.GetBBFromVE(lp.ainip.ve))
				this.ACTIVE_IINDEX.put(lp.ainip.name, lp.ainip.gii)
				this.ACTIVE_VE.put(lp.ainip.name, lp.ainip.ve.name)
			}
			else if (lp.ainip.vt == BbDvgTcl.VT.CONSTANT) {
				this.CONSTANT.put(lp.ainip.name, Helpers.getVSPInitSize(lp.ainip))
			}
			else {
				this.PASSIVE_LOOKUP.put(lp.ainip.name, Helpers.getVSPInitSize(lp.ainip))
				this.PASSIVE_LOOKUP_LIST.add(new SimpleEntry<String, Integer>(lp.ainip.name, Helpers.getVSPInitSize(lp.ainip)))
			}
		}
				
		else if (lp instanceof RPRO) {
			for (i : lp.ip) {
				inputSetInputs.add(i)
				inputSet.add(i.outputport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
		}
		
		else if (lp instanceof SAPRO) {
			for (i : lp.ip) {
				inputSetInputs.add(i)
				inputSet.add(i.outputport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
		}		
		
		else if (lp instanceof APRO) {
			for (i : lp.ip) {
				inputSetInputs.add(i)
				inputSet.add(i.outputport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
		}
		
		else if (lp instanceof MAGR) {
			
			if (lp.f !== null) {
				if (lp.f instanceof EquivalenceFork) {
					this.ACTIVE.put(lp.name, lp.aggr.get(0).ip.size)
				}
				else if (lp.f instanceof ConditionalFork) {
					this.PASSIVE_LOOKUP.put(lp.name, lp.aggr.get(0).ip.size)
					this.PASSIVE_LOOKUP_LIST.add(new SimpleEntry<String, Integer>(lp.name, lp.aggr.get(0).ip.size)) 
				}	
			}
			
			else if (lp.o !== null) {
				this.ACTIVE.put(lp.name, lp.aggr.get(0).ip.size)
			}
			else if (lp.or !== null) {
				this.ACTIVE.put(lp.name, lp.aggr.get(0).ip.size)
			}
			else if (lp.x !== null) {
				this.ACTIVE.put(lp.name, lp.aggr.get(0).ip.size)
			}						
			
			for (i : lp.aggr) {
				var List<BbDvgTcl.DVGPort> tmp = new ArrayList<BbDvgTcl.DVGPort>()
				for (j : i.ip) {
					inputSetInputs.add(j)
					tmp.add(j.outputport)
					var BbDvgTcl.Pattern lpr = Helpers.getPattern(j.outputport)
					
					if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
						this.IS_RESOLVED_MAP.put(lpr,false)
						resolveNext(lpr)
					}
					else {
						if (!this.IS_RESOLVED_MAP.get(lpr)) {
							resolveNext(lpr)
						}
					}
				}
				inputSetAg.add(tmp)
			}
		}
		
		else if (lp instanceof CONT) {
			for (i : lp.ip) {
				inputSetInputs.add(i)
				inputSet.add(i.outputport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
			
			var EObject tmp = lp.ipp
			if (tmp instanceof InputWSMPort) {
				inputSetInputs.add(tmp)
				inputSet.add(tmp.outputwsmport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(tmp.outputwsmport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
		}
		
		else if (lp instanceof EPROD) {
			for (i : lp.ip) {
				inputSetInputs.add(i)
				inputSet.add(i.outputport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
		}		
		
		else if (lp instanceof TRAN) {
			inputSetInputs.add(lp.ip)
			inputSet.add(lp.ip.outputport)
			var BbDvgTcl.Pattern lpr = Helpers.getPattern(lp.ip.outputport)
			
			if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
				this.IS_RESOLVED_MAP.put(lpr,false)
				resolveNext(lpr)
			}
			else {
				if (!this.IS_RESOLVED_MAP.get(lpr)) {
					resolveNext(lpr)
				}
			}
		}
		
		else if (lp instanceof COMF) {
			inputSetInputs.add(lp.ip)
			inputSet.add(lp.ip.outputport)
			var BbDvgTcl.Pattern lpr = Helpers.getPattern(lp.ip.outputport)
			if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
				this.IS_RESOLVED_MAP.put(lpr,false)
				resolveNext(lpr)
			}
			else {
				if (!this.IS_RESOLVED_MAP.get(lpr)) {
					resolveNext(lpr)
				}
			}
			
			inputSetInputs.add(lp.icp)
			inputSet.add(lp.icp.outputcport)
			lpr = Helpers.getPattern(lp.icp.outputcport)
			
			if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
				this.IS_RESOLVED_MAP.put(lpr,false)
				resolveNext(lpr)
			}
			
			else {
				if (!this.IS_RESOLVED_MAP.get(lpr)) {
					resolveNext(lpr)
				}
			}
		}
		
		else if (lp instanceof PTCC) {
			for (i : lp.ip) {
				inputSetInputs.add(i)
				inputSet.add(i.outputport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(i.outputport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
			
			var EObject tmp = lp.ipp
			if (tmp instanceof InputWSMPort) {
				inputSetInputs.add(tmp)
				inputSet.add(tmp.outputwsmport)
				var BbDvgTcl.Pattern lpr = Helpers.getPattern(tmp.outputwsmport)
				
				if (!this.IS_RESOLVED_MAP.containsKey(lpr)) {
					this.IS_RESOLVED_MAP.put(lpr,false)
					resolveNext(lpr)
				}
				
				else {
					if (!this.IS_RESOLVED_MAP.get(lpr)) {
						resolveNext(lpr)
					}
				}
			}
		}
	
		// all dependencies of lp are already resolved/generated
		// call this function with name(list of inputs) where the inputs are instances of nodes with assigned vsps
		
		resolve(lp, inputSetInputs)
		this.IS_RESOLVED_MAP.put(lp, true)
		
		if (lp instanceof MAGR) {
			this.CALL_SEQUENCE_CODE.append(JavaFunctions.generateCallSequenceCodeAg(lp.name, inputSetAg))
		}
		else if (!(lp instanceof INIT)) {
			this.CALL_SEQUENCE_CODE.append(JavaFunctions.generateCallSequenceCode(lp.name, inputSet))
		}
	}
	
	def resolve(BbDvgTcl.Pattern lp, List<BbDvgTcl.AbstractInputPort> inputSet) {
		
		// If we are here to rlve/generate lp all its dependencies/VSPs are already resolved/generated
		
		//System.out.println("+++++++++++++++++++++++++++++++++ RESOLVE "+ lp.name+"+++++++++++++++++++++++++++++++++++++++++++++++")
		
		if (lp instanceof COMF) { 
			var COMFPattern comfp = new COMFPattern(lp)
			comfp.generate()
			this.LOCAL_RESOLUTION_CODE.append(comfp.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")
		}
		
		else if (lp instanceof RPRO) {
			var RPROPattern rprop
			if (lp.opp !== null && lp.op !== null) {
				System.out.println("ERROR: RPRO can not have both a OutputNode and a OutputPSNode!")
			}
			else if (lp.opp !== null && lp.op === null) {
				rprop = new RPROPattern(lp, inputSet, true)
				rprop.generate()
				this.LOCAL_RESOLUTION_CODE.append(rprop.getCode())
				this.LOCAL_RESOLUTION_CODE.append("\n\n")
			}
			else if (lp.opp === null && lp.op !== null) {
				rprop = new RPROPattern(lp, inputSet, false)
				rprop.generate()
				this.LOCAL_RESOLUTION_CODE.append(rprop.getCode())
				this.LOCAL_RESOLUTION_CODE.append("\n\n")
			}
			else {
				System.out.println("ERROR: RPRO has no OutputPort!")
			}
		}
		
		else if (lp instanceof SAPRO) {
			var SAPROPattern saprop = new SAPROPattern(lp, inputSet)
			saprop.generate()
			this.LOCAL_RESOLUTION_CODE.append(saprop.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")
		}
		
		else if (lp instanceof APRO) { 
			var APROPattern aprop = new APROPattern(lp, inputSet, false)
			aprop.generate()
			this.LOCAL_RESOLUTION_CODE.append(aprop.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")
		}
		
		else if (lp instanceof MAGR) {
			var MAGRPattern magrp = new MAGRPattern(lp)
			magrp.generate()
			this.LOCAL_RESOLUTION_CODE.append(magrp.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")			
		}
		
		else if (lp instanceof TRAN) {
			var TRANPattern tranp = new TRANPattern(lp)
			tranp.generate()
			this.LOCAL_RESOLUTION_CODE.append(tranp.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")
		}
		
		else if (lp instanceof CONT) {
			var CONTPattern contp = new CONTPattern(lp)
			contp.generate()
			this.LOCAL_RESOLUTION_CODE.append(contp.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")			
		}
		
		else if (lp instanceof EPROD) {
			var EPRODPattern eprop = new EPRODPattern(lp)
			eprop.generate()
			this.LOCAL_RESOLUTION_CODE.append(eprop.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")	
		}
		
		else if (lp instanceof PTCC) {
			var PTCCPattern ptccp = new PTCCPattern(lp)
			ptccp.generate()
			this.LOCAL_RESOLUTION_CODE.append(ptccp.getCode())
			this.LOCAL_RESOLUTION_CODE.append("\n\n")				
		}
	}
	
	def generateInitCode() {
		'''
		void init() {
			this.NODE_COLLECTION = new HashMap<String, Node>();
			List<Object> leafValues;
			List<List<Object>> leafValues_2;
			List<Map<String,Double>> leafValuesPsMapList;
			Map<String,Double> leafValuesPsMap;
			NodeObject nodeObject;
			NodeObjectList nodeObjectList;
			NodePs nodePs;
			Random random;
			String[] dataFromFile;
		
			«this.INITIALIZATION_CODE»
		}
		'''
	}	
	
	def generateSolveCode(String outputName) {
		'''
		class Solve {
			private Map<String, Node> NODE_COLLECTION;
			
				«JavaFunctions.generateGetCartesianProduct»
				«JavaFunctions.generateIsSAM»
				«JavaFunctions.generateIsValidCombinationIgnoreResource»
				«JavaFunctions.generateIsDominated»
				«JavaFunctions.generateMaxFunction» 
				«JavaFunctions.generateMinFunction»
				«JavaFunctions.generateGetDataFromFile»
				«this.LOCAL_RESOLUTION_CODE»
				«generateInitCode»
				«JavaFunctions.generateCreateJSONMessageEntry»
				«FinalEvaluation.generateSolveCode(outputName, this.finalOperationIsMax, this.CALL_SEQUENCE_CODE.toString, this.ACTIVE, this.PASSIVE_LOOKUP, this.ACTIVE_BBNAME, this.ACTIVE_IINDEX, this.ACTIVE_VE)»
		}
		'''
	}
	
	def generateDVGSolverCode(String dvgName, String outputName) {
		'''
		«generateSolveCode(outputName)»

		public class DVGSolver_«dvgName» {
			public static void main (String[] args) {
				Solve solve = new Solve();
				solve.init();
				solve.solve();
			}
		}
		'''
	}
}
