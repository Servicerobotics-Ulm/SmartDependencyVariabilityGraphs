/*
 * generated by Xtext 2.21.0
 */
package org.xtext.bb.generator 

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import BbDvgTcl.BuildingBlockDescription
import BbDvgTcl.BlockType
import BbDvgTcl.BuildingBlock
import BbDvgTcl.DVG
import BbDvgTcl.Parallel
import BbDvgTcl.EquivalenceFork
import java.util.Map
import java.util.HashMap
import java.util.List
import java.util.ArrayList
import org.eclipse.emf.ecore.EObject

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BbDslGenerator extends AbstractGenerator {
	
	var BuildingBlock problemBB
	var DVG problemDVG
	var Map<Integer, BuildingBlockDescription> solutionBB	
	SolverGenerationForSingleRobotWithFixedAllocation sgfsrwfa
	
	boolean isValid
		
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		var String code = ""
		
		code += Import.getImportCode() + "\n"
		code += Node.generateNodeClassCode + "\n"
		code += Node.generateNodeObjectClassCode + "\n"
		code += Node.generateNodeObjectListClassCode + "\n"
		code += Node.generateNodePsClassCode + "\n"
		
		this.isValid = false
		
		for (i : resource.allContents.toIterable.filter(BuildingBlockDescription)) {
			code += start(i)
		}
		
		if (isValid) {
			fsa.generateFile("DVGSolver_"+this.problemDVG.name+".java", code);
		}
		else {
			System.err.println("ERROR: Invalid Model!")
		}
	}
	
	def String start(BuildingBlockDescription bbd) {
		
		var BuildingBlock rootBlock = bbd.bb.get(0)
		if (rootBlock.blocktype == BlockType.ALLOCATABLE) {
			println("This is a model for multi robot task allocations!")
			if (rootBlock.allocationCandidates.size > 0) {	
				this.isValid = true
				this.problemBB = rootBlock
				if (bbd.dvg !== null) {
					this.problemDVG = bbd.dvg
				}
				this.solutionBB = new HashMap<Integer, BuildingBlockDescription>()
				
				for (var int i = 0; i < this.problemBB.allocationCandidates.size; i++) {
					this.solutionBB.put(i, this.problemBB.allocationCandidates.get(i))
				}
				if (isEQUFMom(rootBlock)) {
					
					println("This is a EQUF model of model composition!")
					var EObject tmp = rootBlock.dt.get(0)
					if (tmp instanceof EquivalenceFork) {
						return handleMultiRobotTaskAllocationEQUFMom(tmp)
					}
				}
				else if (isParallelMom(rootBlock)) {
					
					println("This is a Parallel model of model composition!")
					var EObject tmp = rootBlock.dt.get(0)
					if (tmp instanceof Parallel) {
						return handleMultiRobotTaskAllocationParallelMom(tmp)
					}					
				}
				else {
					return handleMultiRobotTaskAllocation()
				}
			}
			else {
				System.err.println("ERROR: There are no allocation candidates specified!")
				return ""
			}
		}
		
		else {
			println("This is a model for a single robot with fixed allocation!")
			this.sgfsrwfa = new SolverGenerationForSingleRobotWithFixedAllocation()
			if (bbd.dvg !== null) {
				this.isValid = true
				this.problemDVG = bbd.dvg
				return this.sgfsrwfa.getDVGSolverCode(this.problemDVG)
			}
			else {
				System.err.println("ERROR: BuildingBlockDescription has no reference to a DVG!")
				return ""
			}
		}
		
	}
	
	def String handleMultiRobotTaskAllocation() {
		var BuildingBlockMatching bbm = new BuildingBlockMatching()
		bbm.start(this.problemBB, this.problemDVG)
		printAllocations(bbm.allocations)
		var SolutionInterfaceMatching sim = new SolutionInterfaceMatching()
		sim.start(this.problemDVG, this.solutionBB, bbm.allocations)
		var SolverGenerationForMultiRobotTaskAllocation sgfmrta = new SolverGenerationForMultiRobotTaskAllocation()
		return sgfmrta.start(this.problemDVG, bbm.allocations, sim.solutionDVGPattern, false)		
	}
	
	def String handleMultiRobotTaskAllocationEQUFMom(EquivalenceFork ef) {
		var String code = ""
		var List<VariabilityInformation> variabilityInformationList // the variability information for each variant of the EQUF
		variabilityInformationList = new ArrayList<VariabilityInformation>()
		// We go through all variants of the EQUF and do bb-matching, si-matching and dvg-generation and store relevant variability information in this.variabilityInformationList
		for (var int i = 0; i < ef.c.size(); i++) {
			if (ef.c.get(i).bbr !== null) {
				var EObject bbd = ef.c.get(i).bbr.eContainer
				if (bbd instanceof BuildingBlockDescription) {
					var BuildingBlockMatching bbm = new BuildingBlockMatching()
					bbm.start(ef.c.get(i).bbr, bbd.dvg)
					printAllocations(bbm.allocations)
					var SolutionInterfaceMatching sim = new SolutionInterfaceMatching()
					sim.start(bbd.dvg, this.solutionBB, bbm.allocations)
					var SolverGenerationForMultiRobotTaskAllocation sgfmrta = new SolverGenerationForMultiRobotTaskAllocation()
					code += sgfmrta.start(bbd.dvg, bbm.allocations, sim.solutionDVGPattern, true)	
					var VariabilityInformation magd = new VariabilityInformation()
					magd.numberAllocations = bbm.allocationsNumber
					magd.active = sgfmrta.active
					magd.passive = sgfmrta.passive
					variabilityInformationList.add(magd)
				}	
				else {
					System.err.println("ERROR in handleMultiRobotTaskAllocationEQUFMom: bbd NOT instanceof BuildingBlockDescription!")
				}					
			}
			else {
				System.err.println("ERROR in handleMultiRobotTaskAllocationEQUFMom: bbr is null!")
			}					
		}
		var EqufModelOfModels emom = new EqufModelOfModels()
		emom.start(this.problemDVG, variabilityInformationList)
		code += emom.code
		code += mainCode	
		return code
	}
	
	def String handleMultiRobotTaskAllocationEQUFMom(EquivalenceFork ef, List<VariabilityInformation> vil, DVG dvg) {
		var String code = ""
		// We go through all variants of the EQUF and do bb-matching, si-matching and dvg-generation and store relevant variability information in this.variabilityInformationList
		for (var int i = 0; i < ef.c.size(); i++) {
			if (ef.c.get(i).bbr !== null) {
				var EObject bbd = ef.c.get(i).bbr.eContainer
				if (bbd instanceof BuildingBlockDescription) {
					var BuildingBlockMatching bbm = new BuildingBlockMatching()
					bbm.start(ef.c.get(i).bbr, bbd.dvg)
					printAllocations(bbm.allocations)
					var SolutionInterfaceMatching sim = new SolutionInterfaceMatching()
					sim.start(bbd.dvg, this.solutionBB, bbm.allocations)
					var SolverGenerationForMultiRobotTaskAllocation sgfmrta = new SolverGenerationForMultiRobotTaskAllocation()
					code += sgfmrta.start(bbd.dvg, bbm.allocations, sim.solutionDVGPattern, true)	
					var VariabilityInformation magd = new VariabilityInformation()
					magd.numberAllocations = bbm.allocationsNumber
					magd.active = sgfmrta.active
					magd.passive = sgfmrta.passive
					vil.add(magd)
				}	
				else {
					System.err.println("ERROR in handleMultiRobotTaskAllocationEQUFMom: bbd NOT instanceof BuildingBlockDescription!")
				}					
			}
			else {
				System.err.println("ERROR in handleMultiRobotTaskAllocationEQUFMom: bbr is null!")
			}					
		}
		var EqufModelOfModels emom = new EqufModelOfModels()
		emom.start(dvg, vil)
		for (i : vil) {
			i.active.putAll(emom.active)
			i.passive.putAll(emom.passive)
		}
		code += emom.code	
		return code
	}	
	
	def String handleMultiRobotTaskAllocationParallelMom(Parallel pf) {
		var String code = ""
		var List<Boolean> isEQUF = new ArrayList<Boolean>()
		var List<List<VariabilityInformation>> variabilityInformationListList // the variability information for each variant of the Parallel
		variabilityInformationListList = new ArrayList<List<VariabilityInformation>>()
		var List<VariabilityInformation> variabilityInformationList // the variability information for each variant of the EQUF
		// We go through all variants of the Parallel and do bb-matching, si-matching and dvg-generation and store relevant variability information in this.variabilityInformationList
		// We also check if a variant is a EQUF model of model and trigger the procedure if this is the case
		for (var int i = 0; i < pf.c.size(); i++) {
			if (pf.c.get(i).bbr !== null) {
				if (pf.c.get(i).bbr.dt.get(0) instanceof EquivalenceFork && pf.c.get(i).bbr.blocktype == BlockType.ALLOCATABLE) {
					println("This is a EQUF model of model composition!")
					isEQUF.add(true)
					variabilityInformationList = new ArrayList<VariabilityInformation>()
					var EObject tmp = pf.c.get(i).bbr.dt.get(0)
					var EObject tmp2 = tmp.eContainer
					if (tmp instanceof EquivalenceFork) {
						if (tmp2 instanceof BuildingBlockDescription) {
							code += handleMultiRobotTaskAllocationEQUFMom(tmp, variabilityInformationList, tmp2.dvg)
							variabilityInformationListList.add(variabilityInformationList)
						}
					}
				}
				else {
					variabilityInformationList = new ArrayList<VariabilityInformation>() 
					isEQUF.add(false)
					if (pf.c.get(i).bbr !== null) {
						var EObject bbd = pf.c.get(i).bbr.eContainer
						if (bbd instanceof BuildingBlockDescription) {
							var BuildingBlockMatching bbm = new BuildingBlockMatching()
							bbm.start(pf.c.get(i).bbr, bbd.dvg)
							printAllocations(bbm.allocations)
							var SolutionInterfaceMatching sim = new SolutionInterfaceMatching()
							sim.start(bbd.dvg, this.solutionBB, bbm.allocations)
							var SolverGenerationForMultiRobotTaskAllocation sgfmrta = new SolverGenerationForMultiRobotTaskAllocation()
							code += sgfmrta.start(bbd.dvg, bbm.allocations, sim.solutionDVGPattern, true)	
							var VariabilityInformation magd = new VariabilityInformation()
							magd.numberAllocations = bbm.allocationsNumber
							magd.active = sgfmrta.active
							magd.passive = sgfmrta.passive
							variabilityInformationList.add(magd)
							variabilityInformationListList.add(variabilityInformationList)
						}	
						else {
							System.err.println("ERROR in handleMultiRobotTaskAllocationEQUFMom: bbd NOT instanceof BuildingBlockDescription!")
						}	
					}							
				}
			}
			else {
				System.err.println("ERROR in handleMultiRobotTaskAllocationParallelMom: bbr is null!")
			}	
		}
		var ParallelModelOfModels pmom = new ParallelModelOfModels()
		pmom.start(this.problemDVG, variabilityInformationListList)
		code += pmom.code	
		code += mainCode	
		return code		
	}
	
	def printAllocations(List<List<Integer>> allocations) {
		println()
		println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
		println("Possible Allocations for <<ALLOCATABLE>> "+problemBB.name)
		println("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
		for (var int i = 0; i < allocations.size; i++) {
			println("\t---------------------------------------------------------------------")
			println("\tAllocation "+ i+":")
			for (var int j = 0; j < allocations.get(i).size; j++) {
				print("\t"+j+"-th resource group by resource: "+this.solutionBB.get(allocations.get(i).get(j)).name)
				print("\t")
			}
			println()
			println("\t---------------------------------------------------------------------")
		}		
	}
	
	def isEQUFMom(BuildingBlock block) {
		if (block.dt.get(0) instanceof EquivalenceFork && block.dt.get(0).c.get(0).bbr !== null && block.dt.get(0).c.get(0).bbr.blocktype == BlockType.ALLOCATABLE) {
			return true
		}
		else {
			return false
		}
	}
	
	def isParallelMom(BuildingBlock block) {
		if (block.dt.get(0) instanceof Parallel && block.dt.get(0).c.get(0).bbr !== null && block.dt.get(0).c.get(0).bbr.blocktype == BlockType.ALLOCATABLE) {
			return true
		}
		else {
			return false
		}		
	}

	def getMainCode() {
		'''
		public class DVGSolver_«this.problemDVG.name» {
			public static void main (String[] args) {
				«this.problemDVG.name» dvg = new «this.problemDVG.name»();
				dvg.init();
				dvg.solve();
			}
		}		
		'''
	}	
}

class VariabilityInformation {
	public int numberAllocations;
	public Map<String, Integer> active;
	public Map<String, Integer> passive;
}
