/**
 * generated by Xtext 2.21.0
 */
package org.xtext.bb.generator;

import BbDvgTcl.AGGR;
import BbDvgTcl.APRO;
import BbDvgTcl.AbstractInputPort;
import BbDvgTcl.COMF;
import BbDvgTcl.CONT;
import BbDvgTcl.ConditionalFork;
import BbDvgTcl.DVG;
import BbDvgTcl.DVGPort;
import BbDvgTcl.EPROD;
import BbDvgTcl.EquivalenceFork;
import BbDvgTcl.Fork;
import BbDvgTcl.INIT;
import BbDvgTcl.InputPort;
import BbDvgTcl.InputWSMPort;
import BbDvgTcl.Interface;
import BbDvgTcl.MAGR;
import BbDvgTcl.OR;
import BbDvgTcl.Optional;
import BbDvgTcl.PTCC;
import BbDvgTcl.Pattern;
import BbDvgTcl.RPRO;
import BbDvgTcl.SAPRO;
import BbDvgTcl.TRAN;
import BbDvgTcl.VT;
import BbDvgTcl.XOR;
import com.google.common.base.Objects;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.InputOutput;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class SolverGenerationForSingleRobotWithFixedAllocation {
  private StringBuilder INITIALIZATION_CODE;

  private StringBuilder LOCAL_RESOLUTION_CODE;

  private StringBuilder CALL_SEQUENCE_CODE;

  private Map<Pattern, Boolean> IS_RESOLVED_MAP;

  private Map<String, Integer> PASSIVE_LOOKUP;

  private List<AbstractMap.SimpleEntry<String, Integer>> PASSIVE_LOOKUP_LIST;

  private Map<String, Integer> ACTIVE;

  private Map<String, String> ACTIVE_BBNAME;

  private Map<String, Integer> ACTIVE_IINDEX;

  private Map<String, String> ACTIVE_VE;

  private Map<String, Integer> CONSTANT;

  private boolean finalOperationIsMax;

  public String getDVGSolverCode(final DVG dvg) {
    InputOutput.<String>println("SolverGenerationForSingleRobotWithFixedAllocation started!");
    HashMap<String, Integer> _hashMap = new HashMap<String, Integer>();
    this.PASSIVE_LOOKUP = _hashMap;
    ArrayList<AbstractMap.SimpleEntry<String, Integer>> _arrayList = new ArrayList<AbstractMap.SimpleEntry<String, Integer>>();
    this.PASSIVE_LOOKUP_LIST = _arrayList;
    HashMap<String, Integer> _hashMap_1 = new HashMap<String, Integer>();
    this.ACTIVE = _hashMap_1;
    HashMap<String, String> _hashMap_2 = new HashMap<String, String>();
    this.ACTIVE_BBNAME = _hashMap_2;
    HashMap<String, Integer> _hashMap_3 = new HashMap<String, Integer>();
    this.ACTIVE_IINDEX = _hashMap_3;
    HashMap<String, String> _hashMap_4 = new HashMap<String, String>();
    this.ACTIVE_VE = _hashMap_4;
    HashMap<String, Integer> _hashMap_5 = new HashMap<String, Integer>();
    this.CONSTANT = _hashMap_5;
    StringBuilder _stringBuilder = new StringBuilder();
    this.INITIALIZATION_CODE = _stringBuilder;
    StringBuilder _stringBuilder_1 = new StringBuilder();
    this.LOCAL_RESOLUTION_CODE = _stringBuilder_1;
    StringBuilder _stringBuilder_2 = new StringBuilder();
    this.CALL_SEQUENCE_CODE = _stringBuilder_2;
    HashMap<Pattern, Boolean> _hashMap_6 = new HashMap<Pattern, Boolean>();
    this.IS_RESOLVED_MAP = _hashMap_6;
    this.finalOperationIsMax = Helpers.GetFinalOperationIsMax(dvg.getFinalOperation());
    this.generate(dvg);
    InputOutput.<String>println("---------");
    InputOutput.<String>println("PASSIVE LOOKUP");
    Set<Map.Entry<String, Integer>> _entrySet = this.PASSIVE_LOOKUP.entrySet();
    for (final Map.Entry<String, Integer> i : _entrySet) {
      String _key = i.getKey();
      String _plus = (_key + " : ");
      Integer _value = i.getValue();
      String _plus_1 = (_plus + _value);
      InputOutput.<String>println(_plus_1);
    }
    InputOutput.<String>println("PASSIVE LOOKUP_LIST");
    for (final AbstractMap.SimpleEntry<String, Integer> i_1 : this.PASSIVE_LOOKUP_LIST) {
      String _key_1 = i_1.getKey();
      String _plus_2 = (_key_1 + " : ");
      Integer _value_1 = i_1.getValue();
      String _plus_3 = (_plus_2 + _value_1);
      InputOutput.<String>println(_plus_3);
    }
    InputOutput.<String>println("ACTIVE");
    Set<Map.Entry<String, Integer>> _entrySet_1 = this.ACTIVE.entrySet();
    for (final Map.Entry<String, Integer> i_2 : _entrySet_1) {
      String _key_2 = i_2.getKey();
      String _plus_4 = (_key_2 + " : ");
      Integer _value_2 = i_2.getValue();
      String _plus_5 = (_plus_4 + _value_2);
      InputOutput.<String>println(_plus_5);
    }
    InputOutput.<String>println("---------");
    String outputName = null;
    String _outputName = dvg.getOutputName();
    boolean _tripleNotEquals = (_outputName != null);
    if (_tripleNotEquals) {
      String _outputName_1 = dvg.getOutputName();
      boolean _equals = Objects.equal(_outputName_1, "");
      if (_equals) {
        outputName = "null";
      } else {
        outputName = dvg.getOutputName();
      }
    } else {
      outputName = "null";
    }
    return this.generateDVGSolverCode(dvg.getName(), outputName).toString();
  }

  public void generate(final DVG dvg) {
    HashMap<Pattern, Boolean> _hashMap = new HashMap<Pattern, Boolean>();
    this.IS_RESOLVED_MAP = _hashMap;
    EList<Pattern> _pattern = dvg.getPattern();
    for (final Pattern i : _pattern) {
      this.IS_RESOLVED_MAP.put(i, Boolean.valueOf(false));
    }
    EList<Pattern> _pattern_1 = dvg.getPattern();
    for (final Pattern i_1 : _pattern_1) {
      Boolean _get = this.IS_RESOLVED_MAP.get(i_1);
      boolean _not = (!(_get).booleanValue());
      if (_not) {
        this.resolveNext(i_1);
      }
    }
  }

  public StringBuilder resolveNext(final Pattern lp) {
    StringBuilder _xblockexpression = null;
    {
      List<DVGPort> inputSet = new ArrayList<DVGPort>();
      List<List<DVGPort>> inputSetAg = new ArrayList<List<DVGPort>>();
      List<AbstractInputPort> inputSetInputs = new ArrayList<AbstractInputPort>();
      if ((lp instanceof INIT)) {
        Interface _interface = ((INIT)lp).getAinip().getInterface();
        boolean _tripleEquals = (_interface == null);
        if (_tripleEquals) {
          this.INITIALIZATION_CODE.append(Leafs.generateLeaf(((INIT)lp).getAinip()));
        } else {
          if (((((INIT)lp).getAinip().getInterface() != null) && Objects.equal(((INIT)lp).getAinip().getInterface(), Interface.INTERNAL))) {
            this.INITIALIZATION_CODE.append(Leafs.generateLeaf(((INIT)lp).getAinip()));
          } else {
            if (((((INIT)lp).getAinip().getInterface() != null) && Objects.equal(((INIT)lp).getAinip().getInterface(), Interface.EXTERNAL))) {
              String res = "";
              boolean _isComplexDo = Helpers.isComplexDo(((INIT)lp).getAinip().getVe());
              if (_isComplexDo) {
                String _res = res;
                CharSequence _generateLeafValuesComplexTcl = Leafs.generateLeafValuesComplexTcl(((INIT)lp).getAinip().getName());
                res = (_res + _generateLeafValuesComplexTcl);
              } else {
                String _res_1 = res;
                CharSequence _generateLeafValuesTcl = Leafs.generateLeafValuesTcl(((INIT)lp).getAinip().getName());
                res = (_res_1 + _generateLeafValuesTcl);
              }
              this.INITIALIZATION_CODE.append(res);
            }
          }
        }
        VT _vt = ((INIT)lp).getAinip().getVt();
        boolean _equals = Objects.equal(_vt, VT.ACTIVE);
        if (_equals) {
          this.ACTIVE.put(((INIT)lp).getAinip().getName(), Integer.valueOf(Helpers.getVSPInitSize(((INIT)lp).getAinip())));
          this.ACTIVE_BBNAME.put(((INIT)lp).getAinip().getName(), Helpers.GetBBFromVE(((INIT)lp).getAinip().getVe()));
          this.ACTIVE_IINDEX.put(((INIT)lp).getAinip().getName(), Integer.valueOf(((INIT)lp).getAinip().getGii()));
          this.ACTIVE_VE.put(((INIT)lp).getAinip().getName(), ((INIT)lp).getAinip().getVe().getName());
        } else {
          VT _vt_1 = ((INIT)lp).getAinip().getVt();
          boolean _equals_1 = Objects.equal(_vt_1, VT.CONSTANT);
          if (_equals_1) {
            this.CONSTANT.put(((INIT)lp).getAinip().getName(), Integer.valueOf(Helpers.getVSPInitSize(((INIT)lp).getAinip())));
          } else {
            this.PASSIVE_LOOKUP.put(((INIT)lp).getAinip().getName(), Integer.valueOf(Helpers.getVSPInitSize(((INIT)lp).getAinip())));
            String _name = ((INIT)lp).getAinip().getName();
            int _vSPInitSize = Helpers.getVSPInitSize(((INIT)lp).getAinip());
            AbstractMap.SimpleEntry<String, Integer> _simpleEntry = new AbstractMap.SimpleEntry<String, Integer>(_name, Integer.valueOf(_vSPInitSize));
            this.PASSIVE_LOOKUP_LIST.add(_simpleEntry);
          }
        }
      } else {
        if ((lp instanceof RPRO)) {
          EList<InputPort> _ip = ((RPRO)lp).getIp();
          for (final InputPort i : _ip) {
            {
              inputSetInputs.add(i);
              inputSet.add(i.getOutputport());
              Pattern lpr = Helpers.getPattern(i.getOutputport());
              boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
              boolean _not = (!_containsKey);
              if (_not) {
                this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                this.resolveNext(lpr);
              } else {
                Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                boolean _not_1 = (!(_get).booleanValue());
                if (_not_1) {
                  this.resolveNext(lpr);
                }
              }
            }
          }
        } else {
          if ((lp instanceof SAPRO)) {
            EList<InputPort> _ip_1 = ((SAPRO)lp).getIp();
            for (final InputPort i_1 : _ip_1) {
              {
                inputSetInputs.add(i_1);
                inputSet.add(i_1.getOutputport());
                Pattern lpr = Helpers.getPattern(i_1.getOutputport());
                boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
                boolean _not = (!_containsKey);
                if (_not) {
                  this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                  this.resolveNext(lpr);
                } else {
                  Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                  boolean _not_1 = (!(_get).booleanValue());
                  if (_not_1) {
                    this.resolveNext(lpr);
                  }
                }
              }
            }
          } else {
            if ((lp instanceof APRO)) {
              EList<InputPort> _ip_2 = ((APRO)lp).getIp();
              for (final InputPort i_2 : _ip_2) {
                {
                  inputSetInputs.add(i_2);
                  inputSet.add(i_2.getOutputport());
                  Pattern lpr = Helpers.getPattern(i_2.getOutputport());
                  boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
                  boolean _not = (!_containsKey);
                  if (_not) {
                    this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                    this.resolveNext(lpr);
                  } else {
                    Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                    boolean _not_1 = (!(_get).booleanValue());
                    if (_not_1) {
                      this.resolveNext(lpr);
                    }
                  }
                }
              }
            } else {
              if ((lp instanceof MAGR)) {
                Fork _f = ((MAGR)lp).getF();
                boolean _tripleNotEquals = (_f != null);
                if (_tripleNotEquals) {
                  Fork _f_1 = ((MAGR)lp).getF();
                  if ((_f_1 instanceof EquivalenceFork)) {
                    this.ACTIVE.put(((MAGR)lp).getName(), Integer.valueOf(((MAGR)lp).getAggr().get(0).getIp().size()));
                  } else {
                    Fork _f_2 = ((MAGR)lp).getF();
                    if ((_f_2 instanceof ConditionalFork)) {
                      this.PASSIVE_LOOKUP.put(((MAGR)lp).getName(), Integer.valueOf(((MAGR)lp).getAggr().get(0).getIp().size()));
                      String _name_1 = ((MAGR)lp).getName();
                      int _size = ((MAGR)lp).getAggr().get(0).getIp().size();
                      AbstractMap.SimpleEntry<String, Integer> _simpleEntry_1 = new AbstractMap.SimpleEntry<String, Integer>(_name_1, Integer.valueOf(_size));
                      this.PASSIVE_LOOKUP_LIST.add(_simpleEntry_1);
                    }
                  }
                } else {
                  Optional _o = ((MAGR)lp).getO();
                  boolean _tripleNotEquals_1 = (_o != null);
                  if (_tripleNotEquals_1) {
                    this.ACTIVE.put(((MAGR)lp).getName(), Integer.valueOf(((MAGR)lp).getAggr().get(0).getIp().size()));
                  } else {
                    OR _or = ((MAGR)lp).getOr();
                    boolean _tripleNotEquals_2 = (_or != null);
                    if (_tripleNotEquals_2) {
                      this.ACTIVE.put(((MAGR)lp).getName(), Integer.valueOf(((MAGR)lp).getAggr().get(0).getIp().size()));
                    } else {
                      XOR _x = ((MAGR)lp).getX();
                      boolean _tripleNotEquals_3 = (_x != null);
                      if (_tripleNotEquals_3) {
                        this.ACTIVE.put(((MAGR)lp).getName(), Integer.valueOf(((MAGR)lp).getAggr().get(0).getIp().size()));
                      }
                    }
                  }
                }
                EList<AGGR> _aggr = ((MAGR)lp).getAggr();
                for (final AGGR i_3 : _aggr) {
                  {
                    List<DVGPort> tmp = new ArrayList<DVGPort>();
                    EList<InputPort> _ip_3 = i_3.getIp();
                    for (final InputPort j : _ip_3) {
                      {
                        inputSetInputs.add(j);
                        tmp.add(j.getOutputport());
                        Pattern lpr = Helpers.getPattern(j.getOutputport());
                        boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
                        boolean _not = (!_containsKey);
                        if (_not) {
                          this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                          this.resolveNext(lpr);
                        } else {
                          Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                          boolean _not_1 = (!(_get).booleanValue());
                          if (_not_1) {
                            this.resolveNext(lpr);
                          }
                        }
                      }
                    }
                    inputSetAg.add(tmp);
                  }
                }
              } else {
                if ((lp instanceof CONT)) {
                  EList<InputPort> _ip_3 = ((CONT)lp).getIp();
                  for (final InputPort i_4 : _ip_3) {
                    {
                      inputSetInputs.add(i_4);
                      inputSet.add(i_4.getOutputport());
                      Pattern lpr = Helpers.getPattern(i_4.getOutputport());
                      boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
                      boolean _not = (!_containsKey);
                      if (_not) {
                        this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                        this.resolveNext(lpr);
                      } else {
                        Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                        boolean _not_1 = (!(_get).booleanValue());
                        if (_not_1) {
                          this.resolveNext(lpr);
                        }
                      }
                    }
                  }
                  EObject tmp = ((CONT)lp).getIpp();
                  if ((tmp instanceof InputWSMPort)) {
                    inputSetInputs.add(((AbstractInputPort)tmp));
                    inputSet.add(((InputWSMPort)tmp).getOutputwsmport());
                    Pattern lpr = Helpers.getPattern(((InputWSMPort)tmp).getOutputwsmport());
                    boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
                    boolean _not = (!_containsKey);
                    if (_not) {
                      this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                      this.resolveNext(lpr);
                    } else {
                      Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                      boolean _not_1 = (!(_get).booleanValue());
                      if (_not_1) {
                        this.resolveNext(lpr);
                      }
                    }
                  }
                } else {
                  if ((lp instanceof EPROD)) {
                    EList<InputPort> _ip_4 = ((EPROD)lp).getIp();
                    for (final InputPort i_5 : _ip_4) {
                      {
                        inputSetInputs.add(i_5);
                        inputSet.add(i_5.getOutputport());
                        Pattern lpr_1 = Helpers.getPattern(i_5.getOutputport());
                        boolean _containsKey_1 = this.IS_RESOLVED_MAP.containsKey(lpr_1);
                        boolean _not_2 = (!_containsKey_1);
                        if (_not_2) {
                          this.IS_RESOLVED_MAP.put(lpr_1, Boolean.valueOf(false));
                          this.resolveNext(lpr_1);
                        } else {
                          Boolean _get_1 = this.IS_RESOLVED_MAP.get(lpr_1);
                          boolean _not_3 = (!(_get_1).booleanValue());
                          if (_not_3) {
                            this.resolveNext(lpr_1);
                          }
                        }
                      }
                    }
                  } else {
                    if ((lp instanceof TRAN)) {
                      inputSetInputs.add(((TRAN)lp).getIp());
                      inputSet.add(((TRAN)lp).getIp().getOutputport());
                      Pattern lpr_1 = Helpers.getPattern(((TRAN)lp).getIp().getOutputport());
                      boolean _containsKey_1 = this.IS_RESOLVED_MAP.containsKey(lpr_1);
                      boolean _not_2 = (!_containsKey_1);
                      if (_not_2) {
                        this.IS_RESOLVED_MAP.put(lpr_1, Boolean.valueOf(false));
                        this.resolveNext(lpr_1);
                      } else {
                        Boolean _get_1 = this.IS_RESOLVED_MAP.get(lpr_1);
                        boolean _not_3 = (!(_get_1).booleanValue());
                        if (_not_3) {
                          this.resolveNext(lpr_1);
                        }
                      }
                    } else {
                      if ((lp instanceof COMF)) {
                        inputSetInputs.add(((COMF)lp).getIp());
                        inputSet.add(((COMF)lp).getIp().getOutputport());
                        Pattern lpr_2 = Helpers.getPattern(((COMF)lp).getIp().getOutputport());
                        boolean _containsKey_2 = this.IS_RESOLVED_MAP.containsKey(lpr_2);
                        boolean _not_4 = (!_containsKey_2);
                        if (_not_4) {
                          this.IS_RESOLVED_MAP.put(lpr_2, Boolean.valueOf(false));
                          this.resolveNext(lpr_2);
                        } else {
                          Boolean _get_2 = this.IS_RESOLVED_MAP.get(lpr_2);
                          boolean _not_5 = (!(_get_2).booleanValue());
                          if (_not_5) {
                            this.resolveNext(lpr_2);
                          }
                        }
                        inputSetInputs.add(((COMF)lp).getIcp());
                        inputSet.add(((COMF)lp).getIcp().getOutputcport());
                        lpr_2 = Helpers.getPattern(((COMF)lp).getIcp().getOutputcport());
                        boolean _containsKey_3 = this.IS_RESOLVED_MAP.containsKey(lpr_2);
                        boolean _not_6 = (!_containsKey_3);
                        if (_not_6) {
                          this.IS_RESOLVED_MAP.put(lpr_2, Boolean.valueOf(false));
                          this.resolveNext(lpr_2);
                        } else {
                          Boolean _get_3 = this.IS_RESOLVED_MAP.get(lpr_2);
                          boolean _not_7 = (!(_get_3).booleanValue());
                          if (_not_7) {
                            this.resolveNext(lpr_2);
                          }
                        }
                      } else {
                        if ((lp instanceof PTCC)) {
                          EList<InputPort> _ip_5 = ((PTCC)lp).getIp();
                          for (final InputPort i_6 : _ip_5) {
                            {
                              inputSetInputs.add(i_6);
                              inputSet.add(i_6.getOutputport());
                              Pattern lpr_3 = Helpers.getPattern(i_6.getOutputport());
                              boolean _containsKey_4 = this.IS_RESOLVED_MAP.containsKey(lpr_3);
                              boolean _not_8 = (!_containsKey_4);
                              if (_not_8) {
                                this.IS_RESOLVED_MAP.put(lpr_3, Boolean.valueOf(false));
                                this.resolveNext(lpr_3);
                              } else {
                                Boolean _get_4 = this.IS_RESOLVED_MAP.get(lpr_3);
                                boolean _not_9 = (!(_get_4).booleanValue());
                                if (_not_9) {
                                  this.resolveNext(lpr_3);
                                }
                              }
                            }
                          }
                          EObject tmp_1 = ((PTCC)lp).getIpp();
                          if ((tmp_1 instanceof InputWSMPort)) {
                            inputSetInputs.add(((AbstractInputPort)tmp_1));
                            inputSet.add(((InputWSMPort)tmp_1).getOutputwsmport());
                            Pattern lpr_3 = Helpers.getPattern(((InputWSMPort)tmp_1).getOutputwsmport());
                            boolean _containsKey_4 = this.IS_RESOLVED_MAP.containsKey(lpr_3);
                            boolean _not_8 = (!_containsKey_4);
                            if (_not_8) {
                              this.IS_RESOLVED_MAP.put(lpr_3, Boolean.valueOf(false));
                              this.resolveNext(lpr_3);
                            } else {
                              Boolean _get_4 = this.IS_RESOLVED_MAP.get(lpr_3);
                              boolean _not_9 = (!(_get_4).booleanValue());
                              if (_not_9) {
                                this.resolveNext(lpr_3);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      this.resolve(lp, inputSetInputs);
      this.IS_RESOLVED_MAP.put(lp, Boolean.valueOf(true));
      StringBuilder _xifexpression = null;
      if ((lp instanceof MAGR)) {
        _xifexpression = this.CALL_SEQUENCE_CODE.append(JavaFunctions.generateCallSequenceCodeAg(((MAGR)lp).getName(), inputSetAg));
      } else {
        StringBuilder _xifexpression_1 = null;
        if ((!(lp instanceof INIT))) {
          _xifexpression_1 = this.CALL_SEQUENCE_CODE.append(JavaFunctions.generateCallSequenceCode(lp.getName(), inputSet));
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }

  public StringBuilder resolve(final Pattern lp, final List<AbstractInputPort> inputSet) {
    StringBuilder _xifexpression = null;
    if ((lp instanceof COMF)) {
      StringBuilder _xblockexpression = null;
      {
        COMFPattern comfp = new COMFPattern(((COMF)lp));
        comfp.generate();
        this.LOCAL_RESOLUTION_CODE.append(comfp.getCode());
        _xblockexpression = this.LOCAL_RESOLUTION_CODE.append("\n\n");
      }
      _xifexpression = _xblockexpression;
    } else {
      StringBuilder _xifexpression_1 = null;
      if ((lp instanceof RPRO)) {
        StringBuilder _xblockexpression_1 = null;
        {
          RPROPattern rprop = null;
          StringBuilder _xifexpression_2 = null;
          if (((((RPRO)lp).getOpp() != null) && (((RPRO)lp).getOp() != null))) {
            System.out.println("ERROR: RPRO can not have both a OutputNode and a OutputPSNode!");
          } else {
            StringBuilder _xifexpression_3 = null;
            if (((((RPRO)lp).getOpp() != null) && (((RPRO)lp).getOp() == null))) {
              StringBuilder _xblockexpression_2 = null;
              {
                RPROPattern _rPROPattern = new RPROPattern(((RPRO)lp), inputSet, true);
                rprop = _rPROPattern;
                rprop.generate();
                this.LOCAL_RESOLUTION_CODE.append(rprop.getCode());
                _xblockexpression_2 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
              }
              _xifexpression_3 = _xblockexpression_2;
            } else {
              StringBuilder _xifexpression_4 = null;
              if (((((RPRO)lp).getOpp() == null) && (((RPRO)lp).getOp() != null))) {
                StringBuilder _xblockexpression_3 = null;
                {
                  RPROPattern _rPROPattern = new RPROPattern(((RPRO)lp), inputSet, false);
                  rprop = _rPROPattern;
                  rprop.generate();
                  this.LOCAL_RESOLUTION_CODE.append(rprop.getCode());
                  _xblockexpression_3 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
                }
                _xifexpression_4 = _xblockexpression_3;
              } else {
                System.out.println("ERROR: RPRO has no OutputPort!");
              }
              _xifexpression_3 = _xifexpression_4;
            }
            _xifexpression_2 = _xifexpression_3;
          }
          _xblockexpression_1 = _xifexpression_2;
        }
        _xifexpression_1 = _xblockexpression_1;
      } else {
        StringBuilder _xifexpression_2 = null;
        if ((lp instanceof SAPRO)) {
          StringBuilder _xblockexpression_2 = null;
          {
            SAPROPattern saprop = new SAPROPattern(((SAPRO)lp), inputSet);
            saprop.generate();
            this.LOCAL_RESOLUTION_CODE.append(saprop.getCode());
            _xblockexpression_2 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
          }
          _xifexpression_2 = _xblockexpression_2;
        } else {
          StringBuilder _xifexpression_3 = null;
          if ((lp instanceof APRO)) {
            StringBuilder _xblockexpression_3 = null;
            {
              APROPattern aprop = new APROPattern(((APRO)lp), inputSet, false);
              aprop.generate();
              this.LOCAL_RESOLUTION_CODE.append(aprop.getCode());
              _xblockexpression_3 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
            }
            _xifexpression_3 = _xblockexpression_3;
          } else {
            StringBuilder _xifexpression_4 = null;
            if ((lp instanceof MAGR)) {
              StringBuilder _xblockexpression_4 = null;
              {
                MAGRPattern magrp = new MAGRPattern(((MAGR)lp));
                magrp.generate();
                this.LOCAL_RESOLUTION_CODE.append(magrp.getCode());
                _xblockexpression_4 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
              }
              _xifexpression_4 = _xblockexpression_4;
            } else {
              StringBuilder _xifexpression_5 = null;
              if ((lp instanceof TRAN)) {
                StringBuilder _xblockexpression_5 = null;
                {
                  TRANPattern tranp = new TRANPattern(((TRAN)lp));
                  tranp.generate();
                  this.LOCAL_RESOLUTION_CODE.append(tranp.getCode());
                  _xblockexpression_5 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
                }
                _xifexpression_5 = _xblockexpression_5;
              } else {
                StringBuilder _xifexpression_6 = null;
                if ((lp instanceof CONT)) {
                  StringBuilder _xblockexpression_6 = null;
                  {
                    CONTPattern contp = new CONTPattern(((CONT)lp));
                    contp.generate();
                    this.LOCAL_RESOLUTION_CODE.append(contp.getCode());
                    _xblockexpression_6 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
                  }
                  _xifexpression_6 = _xblockexpression_6;
                } else {
                  StringBuilder _xifexpression_7 = null;
                  if ((lp instanceof EPROD)) {
                    StringBuilder _xblockexpression_7 = null;
                    {
                      EPRODPattern eprop = new EPRODPattern(((EPROD)lp));
                      eprop.generate();
                      this.LOCAL_RESOLUTION_CODE.append(eprop.getCode());
                      _xblockexpression_7 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
                    }
                    _xifexpression_7 = _xblockexpression_7;
                  } else {
                    StringBuilder _xifexpression_8 = null;
                    if ((lp instanceof PTCC)) {
                      StringBuilder _xblockexpression_8 = null;
                      {
                        PTCCPattern ptccp = new PTCCPattern(((PTCC)lp));
                        ptccp.generate();
                        this.LOCAL_RESOLUTION_CODE.append(ptccp.getCode());
                        _xblockexpression_8 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
                      }
                      _xifexpression_8 = _xblockexpression_8;
                    }
                    _xifexpression_7 = _xifexpression_8;
                  }
                  _xifexpression_6 = _xifexpression_7;
                }
                _xifexpression_5 = _xifexpression_6;
              }
              _xifexpression_4 = _xifexpression_5;
            }
            _xifexpression_3 = _xifexpression_4;
          }
          _xifexpression_2 = _xifexpression_3;
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }

  public CharSequence generateInitCode() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("void init() {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("this.NODE_COLLECTION = new HashMap<String, Node>();");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("List<Object> leafValues;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("List<List<Object>> leafValues_2;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("List<Map<String,Double>> leafValuesPsMapList;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Map<String,Double> leafValuesPsMap;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("NodeObject nodeObject;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("NodeObjectList nodeObjectList;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("NodePs nodePs;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Random random;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] dataFromFile;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append(this.INITIALIZATION_CODE, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }

  public CharSequence generateSolveCode(final String outputName) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("class Solve {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private Map<String, Node> NODE_COLLECTION;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t\t");
    CharSequence _generateGetCartesianProduct = JavaFunctions.generateGetCartesianProduct();
    _builder.append(_generateGetCartesianProduct, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    CharSequence _generateIsSAM = JavaFunctions.generateIsSAM();
    _builder.append(_generateIsSAM, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    CharSequence _generateIsValidCombinationIgnoreResource = JavaFunctions.generateIsValidCombinationIgnoreResource();
    _builder.append(_generateIsValidCombinationIgnoreResource, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    CharSequence _generateIsDominated = JavaFunctions.generateIsDominated();
    _builder.append(_generateIsDominated, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    CharSequence _generateMaxFunction = JavaFunctions.generateMaxFunction();
    _builder.append(_generateMaxFunction, "\t\t");
    _builder.append(" ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    CharSequence _generateMinFunction = JavaFunctions.generateMinFunction();
    _builder.append(_generateMinFunction, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    CharSequence _generateGetDataFromFile = JavaFunctions.generateGetDataFromFile();
    _builder.append(_generateGetDataFromFile, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append(this.LOCAL_RESOLUTION_CODE, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    CharSequence _generateInitCode = this.generateInitCode();
    _builder.append(_generateInitCode, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    CharSequence _generateCreateJSONMessageEntry = JavaFunctions.generateCreateJSONMessageEntry();
    _builder.append(_generateCreateJSONMessageEntry, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    CharSequence _generateSolveCode = FinalEvaluation.generateSolveCode(outputName, this.finalOperationIsMax, this.CALL_SEQUENCE_CODE.toString(), this.ACTIVE, this.PASSIVE_LOOKUP, this.ACTIVE_BBNAME, this.ACTIVE_IINDEX, this.ACTIVE_VE);
    _builder.append(_generateSolveCode, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }

  public CharSequence generateDVGSolverCode(final String dvgName, final String outputName) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _generateSolveCode = this.generateSolveCode(outputName);
    _builder.append(_generateSolveCode);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public class DVGSolver_");
    _builder.append(dvgName);
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("public static void main (String[] args) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("Solve solve = new Solve();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("solve.init();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("solve.solve();");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
}
