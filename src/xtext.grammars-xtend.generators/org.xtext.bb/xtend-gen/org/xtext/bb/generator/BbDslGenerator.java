/**
 * generated by Xtext 2.21.0
 */
package org.xtext.bb.generator;

import bbn.BlockType;
import bbn.BuildingBlock;
import bbn.BuildingBlockDescription;
import bbn.DVG;
import bbn.Decomposition;
import bbn.EquivalenceFork;
import bbn.Parallel;
import bbn.Pattern;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class BbDslGenerator extends AbstractGenerator {
  private Map<Integer, Set<String>> bReq;

  private Map<Integer, Set<String>> bProv;

  private Map<Integer, List<Integer>> capableResource;

  private Set<Integer> allocations;

  private Map<Integer, Set<Integer>> allocationsMap;

  private List<Set<Integer>> allocationsListSet;

  private List<List<Integer>> allocationsListList;

  private List<List<Integer>> allocationsListListNoDuplicates;

  private BuildingBlock problemBB;

  private DVG problemDVG;

  private Map<Integer, BuildingBlockDescription> solutionBB;

  private Map<Integer, List<Pattern>> solutionDVGPattern;

  private SolutionInterfaceMatching sim;

  private BdvgDslGenerator bdvg;

  private DvgDslGenerator dvg;

  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    HashMap<Integer, Set<String>> _hashMap = new HashMap<Integer, Set<String>>();
    this.bReq = _hashMap;
    HashMap<Integer, Set<String>> _hashMap_1 = new HashMap<Integer, Set<String>>();
    this.bProv = _hashMap_1;
    HashMap<Integer, List<Integer>> _hashMap_2 = new HashMap<Integer, List<Integer>>();
    this.capableResource = _hashMap_2;
    HashMap<Integer, Set<Integer>> _hashMap_3 = new HashMap<Integer, Set<Integer>>();
    this.allocationsMap = _hashMap_3;
    String code = null;
    Iterable<BuildingBlockDescription> _filter = Iterables.<BuildingBlockDescription>filter(IteratorExtensions.<EObject>toIterable(resource.getAllContents()), BuildingBlockDescription.class);
    for (final BuildingBlockDescription i : _filter) {
      code = this.root(i);
    }
    String _name = this.problemDVG.getName();
    String _plus = ("DVGSolver_" + _name);
    String _plus_1 = (_plus + ".java");
    fsa.generateFile(_plus_1, code);
  }

  public String root(final BuildingBlockDescription bbd) {
    String _xblockexpression = null;
    {
      boolean isValid = false;
      boolean hasDVGRef = false;
      BuildingBlock rootBlock = bbd.getBb().get(0);
      BlockType _blocktype = rootBlock.getBlocktype();
      boolean _equals = Objects.equal(_blocktype, BlockType.ALLOCATABLE);
      if (_equals) {
        int _size = rootBlock.getAllocationCandidates().size();
        boolean _greaterThan = (_size > 0);
        if (_greaterThan) {
          isValid = true;
        }
      }
      String _xifexpression = null;
      if (isValid) {
        InputOutput.<String>println("This is a valid model for determining allocations!");
        this.problemBB = rootBlock;
        DVG _dvg = bbd.getDvg();
        boolean _tripleNotEquals = (_dvg != null);
        if (_tripleNotEquals) {
          this.problemDVG = bbd.getDvg();
          hasDVGRef = true;
        }
        boolean isEQUFModelOfModels = false;
        boolean isParallelModelOfModels = false;
        Decomposition _get = rootBlock.getDt().get(0);
        if ((_get instanceof EquivalenceFork)) {
          BuildingBlock _bbr = rootBlock.getDt().get(0).getC().get(0).getBbr();
          boolean _tripleNotEquals_1 = (_bbr != null);
          if (_tripleNotEquals_1) {
            BlockType _blocktype_1 = rootBlock.getDt().get(0).getC().get(0).getBbr().getBlocktype();
            boolean _equals_1 = Objects.equal(_blocktype_1, BlockType.ALLOCATABLE);
            if (_equals_1) {
              isEQUFModelOfModels = true;
            }
          }
        }
        Decomposition _get_1 = rootBlock.getDt().get(0);
        if ((_get_1 instanceof Parallel)) {
          BuildingBlock _bbr_1 = rootBlock.getDt().get(0).getC().get(0).getBbr();
          boolean _tripleNotEquals_2 = (_bbr_1 != null);
          if (_tripleNotEquals_2) {
            BlockType _blocktype_2 = rootBlock.getDt().get(0).getC().get(0).getBbr().getBlocktype();
            boolean _equals_2 = Objects.equal(_blocktype_2, BlockType.ALLOCATABLE);
            if (_equals_2) {
              isParallelModelOfModels = true;
            }
          }
        }
        if (isEQUFModelOfModels) {
          InputOutput.<String>println("isEQUFModelOfModels!!!");
          EqufModelOfModels emom = new EqufModelOfModels();
          StringBuilder code = new StringBuilder();
          code.append(emom.start(rootBlock.getDt().get(0), this.problemDVG, false));
          code.append("");
          String _name = this.problemDVG.getName();
          String _plus = ("public class DVGSolver_" + _name);
          String _plus_1 = (_plus + "{");
          code.append(_plus_1);
          code.append("\n\t");
          code.append("public static void main (String[] args) {");
          code.append("\n\t");
          String _name_1 = this.problemDVG.getName();
          String _plus_2 = (_name_1 + " dvg = new ");
          String _name_2 = this.problemDVG.getName();
          String _plus_3 = (_plus_2 + _name_2);
          String _plus_4 = (_plus_3 + "();");
          code.append(_plus_4);
          code.append("dvg.init();");
          code.append("\n\t\t");
          code.append("dvg.solve();");
          code.append("\n\t\t");
          code.append("\n\t");
          code.append("}");
          code.append("\n");
          code.append("}");
          code.append("\n\n");
          return code.toString();
        } else {
          if (isParallelModelOfModels) {
            InputOutput.<String>println("isParallelModelOfModels!!!");
            ParallelModelOfModels pmom = new ParallelModelOfModels();
            StringBuilder code_1 = new StringBuilder();
            code_1.append(pmom.start(rootBlock.getDt().get(0), this.problemDVG));
            code_1.append("\n\t");
            code_1.append("");
            String _name_3 = this.problemDVG.getName();
            String _plus_5 = ("public class DVGSolver_" + _name_3);
            String _plus_6 = (_plus_5 + "{");
            code_1.append(_plus_6);
            code_1.append("\n\t");
            code_1.append("public static void main (String[] args) {");
            code_1.append("\n\t");
            String _name_4 = this.problemDVG.getName();
            String _plus_7 = (_name_4 + " dvg = new ");
            String _name_5 = this.problemDVG.getName();
            String _plus_8 = (_plus_7 + _name_5);
            String _plus_9 = (_plus_8 + "();");
            code_1.append(_plus_9);
            code_1.append("dvg.init();");
            code_1.append("\n\t\t");
            code_1.append("dvg.solve();");
            code_1.append("\n\t\t");
            code_1.append("\n\t");
            code_1.append("}");
            code_1.append("\n");
            code_1.append("}");
            code_1.append("\n\n");
            return code_1.toString();
          } else {
            MatchingAndGeneration mag = new MatchingAndGeneration();
            return mag.start(this.problemBB, this.problemDVG, hasDVGRef, true, false);
          }
        }
      } else {
        String _xblockexpression_1 = null;
        {
          InputOutput.<String>println("This is NOT a valid model for determining multi-robot task allocations!");
          InputOutput.<String>println("Therefore the DVG solver for a concrete building block is generated!");
          DvgDslGenerator _dvgDslGenerator = new DvgDslGenerator();
          this.dvg = _dvgDslGenerator;
          String _xifexpression_1 = null;
          DVG _dvg_1 = bbd.getDvg();
          boolean _tripleNotEquals_3 = (_dvg_1 != null);
          if (_tripleNotEquals_3) {
            this.problemDVG = bbd.getDvg();
            String code_2 = this.dvg.root(this.problemDVG);
            return code_2;
          } else {
            _xifexpression_1 = InputOutput.<String>println("ERROR: BuildingBlockDescription has no reference to a DVG!");
          }
          _xblockexpression_1 = _xifexpression_1;
        }
        _xifexpression = _xblockexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
}
