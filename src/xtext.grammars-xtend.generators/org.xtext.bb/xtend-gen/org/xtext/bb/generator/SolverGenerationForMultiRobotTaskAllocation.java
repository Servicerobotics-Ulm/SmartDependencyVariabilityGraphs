/**
 * generated by Xtext 2.21.0
 */
package org.xtext.bb.generator;

import BbDvgTcl.AGGR;
import BbDvgTcl.APRO;
import BbDvgTcl.AbstractInitPort;
import BbDvgTcl.AbstractInputPort;
import BbDvgTcl.AbstractOutputPort;
import BbDvgTcl.BBContainer;
import BbDvgTcl.COMF;
import BbDvgTcl.CONT;
import BbDvgTcl.ConditionalFork;
import BbDvgTcl.DMAGR;
import BbDvgTcl.DVG;
import BbDvgTcl.DVGPort;
import BbDvgTcl.EPROD;
import BbDvgTcl.EquivalenceFork;
import BbDvgTcl.Fork;
import BbDvgTcl.INIT;
import BbDvgTcl.InputPort;
import BbDvgTcl.InputWSMPort;
import BbDvgTcl.Interface;
import BbDvgTcl.MAGR;
import BbDvgTcl.OR;
import BbDvgTcl.Optional;
import BbDvgTcl.OutputPort;
import BbDvgTcl.PTCC;
import BbDvgTcl.Pattern;
import BbDvgTcl.RPRO;
import BbDvgTcl.SAPRO;
import BbDvgTcl.TRAN;
import BbDvgTcl.VT;
import BbDvgTcl.VariabilityEntity;
import BbDvgTcl.XOR;
import com.google.common.base.Objects;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.InputOutput;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class SolverGenerationForMultiRobotTaskAllocation {
  private StringBuilder INITIALIZATION_CODE;

  private StringBuilder LOCAL_RESOLUTION_CODE;

  private StringBuilder CALL_SEQUENCE_CODE;

  private Map<Pattern, Boolean> IS_RESOLVED_MAP;

  private Map<Pattern, List<String>> DEPENDENCY_MAP;

  private Map<String, Integer> PASSIVE_LOOKUP;

  private List<AbstractMap.SimpleEntry<String, Integer>> PASSIVE_LOOKUP_LIST;

  private Map<String, Integer> ACTIVE;

  private Map<String, Integer> CONSTANT;

  private DynamicSolutionLinks dsl;

  private List<List<Integer>> allocationsListListNoDuplicates;

  private Map<Integer, List<Pattern>> solutionDVGPattern;

  private Map<AbstractOutputPort, List<Pattern>> solutionInitInstances;

  private boolean mom = false;

  private boolean finalOperationIsMax;

  public Map<String, Integer> getActive() {
    return this.ACTIVE;
  }

  public Map<String, Integer> getPassive() {
    return this.PASSIVE_LOOKUP;
  }

  private Map<AbstractOutputPort, Integer> UNIQUE_RESOURCE_ID;

  public String start(final DVG dvg, final List<List<Integer>> allocationsListListNoDuplicates, final Map<Integer, List<Pattern>> solutionDVGPattern, final boolean mom) {
    InputOutput.<String>println("SolverGenerationForMultiRobotTaskAllocation started!");
    this.allocationsListListNoDuplicates = allocationsListListNoDuplicates;
    this.solutionDVGPattern = solutionDVGPattern;
    this.mom = mom;
    HashMap<AbstractOutputPort, List<Pattern>> _hashMap = new HashMap<AbstractOutputPort, List<Pattern>>();
    this.solutionInitInstances = _hashMap;
    HashMap<AbstractOutputPort, Integer> _hashMap_1 = new HashMap<AbstractOutputPort, Integer>();
    this.UNIQUE_RESOURCE_ID = _hashMap_1;
    DynamicSolutionLinks _dynamicSolutionLinks = new DynamicSolutionLinks();
    this.dsl = _dynamicSolutionLinks;
    HashMap<String, Integer> _hashMap_2 = new HashMap<String, Integer>();
    this.PASSIVE_LOOKUP = _hashMap_2;
    ArrayList<AbstractMap.SimpleEntry<String, Integer>> _arrayList = new ArrayList<AbstractMap.SimpleEntry<String, Integer>>();
    this.PASSIVE_LOOKUP_LIST = _arrayList;
    HashMap<String, Integer> _hashMap_3 = new HashMap<String, Integer>();
    this.ACTIVE = _hashMap_3;
    HashMap<String, Integer> _hashMap_4 = new HashMap<String, Integer>();
    this.CONSTANT = _hashMap_4;
    StringBuilder _stringBuilder = new StringBuilder();
    this.INITIALIZATION_CODE = _stringBuilder;
    StringBuilder _stringBuilder_1 = new StringBuilder();
    this.LOCAL_RESOLUTION_CODE = _stringBuilder_1;
    StringBuilder _stringBuilder_2 = new StringBuilder();
    this.CALL_SEQUENCE_CODE = _stringBuilder_2;
    HashMap<Pattern, Boolean> _hashMap_5 = new HashMap<Pattern, Boolean>();
    this.IS_RESOLVED_MAP = _hashMap_5;
    HashMap<Pattern, List<String>> _hashMap_6 = new HashMap<Pattern, List<String>>();
    this.DEPENDENCY_MAP = _hashMap_6;
    this.finalOperationIsMax = Helpers.GetFinalOperationIsMax(dvg.getFinalOperation());
    this.determineAbsoluteDependencies(dvg);
    this.generate(dvg);
    System.out.println("---------");
    System.out.println("PASSIVE LOOKUP");
    Set<Map.Entry<String, Integer>> _entrySet = this.PASSIVE_LOOKUP.entrySet();
    for (final Map.Entry<String, Integer> i : _entrySet) {
      String _key = i.getKey();
      String _plus = (_key + " : ");
      Integer _value = i.getValue();
      String _plus_1 = (_plus + _value);
      System.out.println(_plus_1);
    }
    System.out.println("PASSIVE LOOKUP_LIST");
    for (final AbstractMap.SimpleEntry<String, Integer> i_1 : this.PASSIVE_LOOKUP_LIST) {
      String _key_1 = i_1.getKey();
      String _plus_2 = (_key_1 + " : ");
      Integer _value_1 = i_1.getValue();
      String _plus_3 = (_plus_2 + _value_1);
      System.out.println(_plus_3);
    }
    System.out.println("ACTIVE");
    Set<Map.Entry<String, Integer>> _entrySet_1 = this.ACTIVE.entrySet();
    for (final Map.Entry<String, Integer> i_2 : _entrySet_1) {
      String _key_2 = i_2.getKey();
      String _plus_4 = (_key_2 + " : ");
      Integer _value_2 = i_2.getValue();
      String _plus_5 = (_plus_4 + _value_2);
      System.out.println(_plus_5);
    }
    System.out.println("---------");
    String outputName = null;
    String _outputName = dvg.getOutputName();
    boolean _tripleNotEquals = (_outputName != null);
    if (_tripleNotEquals) {
      String _outputName_1 = dvg.getOutputName();
      boolean _equals = Objects.equal(_outputName_1, "");
      if (_equals) {
        outputName = "null";
      } else {
        outputName = dvg.getOutputName();
      }
    } else {
      outputName = "null";
    }
    return this.generateDVGSolverCode(dvg.getName(), outputName).toString();
  }

  public void determineAbsoluteDependencies(final DVG dvg) {
    this.dsl.determineDMAGRReferences(dvg);
    EList<Pattern> _pattern = dvg.getPattern();
    for (final Pattern i : _pattern) {
      this.IS_RESOLVED_MAP.put(i, Boolean.valueOf(false));
    }
    EList<Pattern> _pattern_1 = dvg.getPattern();
    for (final Pattern i_1 : _pattern_1) {
      this.DEPENDENCY_MAP.put(i_1, this.getNext(i_1));
    }
    EList<BBContainer> _bbcontainer = dvg.getBbcontainer();
    for (final BBContainer i_2 : _bbcontainer) {
      {
        InputOutput.<String>println("######################################### bb container");
        this.determineAbsoluteDependencies(i_2);
      }
    }
  }

  public void determineAbsoluteDependencies(final BBContainer bbc) {
    EList<Pattern> _pattern = bbc.getPattern();
    for (final Pattern i : _pattern) {
      this.DEPENDENCY_MAP.put(i, this.getNext(i));
    }
    EList<BBContainer> _bbcontainer = bbc.getBbcontainer();
    for (final BBContainer i_1 : _bbcontainer) {
      this.determineAbsoluteDependencies(i_1);
    }
  }

  public List<String> getNext(final Pattern lp) {
    List<String> stringList = new ArrayList<String>();
    if ((lp instanceof RPRO)) {
      EList<InputPort> _ip = ((RPRO)lp).getIp();
      for (final InputPort i : _ip) {
        OutputPort _outputport = i.getOutputport();
        boolean _tripleNotEquals = (_outputport != null);
        if (_tripleNotEquals) {
          stringList.add(i.getOutputport().getName());
          Pattern lpr = Helpers.getPattern(i.getOutputport());
          if ((lpr instanceof MAGR)) {
            AGGR la = Helpers.getAGGR(i.getOutputport());
            stringList.addAll(this.getNext(la, ((MAGR)lpr).getName()));
          } else {
            stringList.addAll(this.getNext(lpr));
          }
        } else {
          stringList.add(i.getName());
        }
      }
    } else {
      if ((lp instanceof SAPRO)) {
        EList<InputPort> _ip_1 = ((SAPRO)lp).getIp();
        for (final InputPort i_1 : _ip_1) {
          OutputPort _outputport_1 = i_1.getOutputport();
          boolean _tripleNotEquals_1 = (_outputport_1 != null);
          if (_tripleNotEquals_1) {
            stringList.add(i_1.getOutputport().getName());
            Pattern lpr_1 = Helpers.getPattern(i_1.getOutputport());
            if ((lpr_1 instanceof MAGR)) {
              AGGR la_1 = Helpers.getAGGR(i_1.getOutputport());
              stringList.addAll(this.getNext(la_1, ((MAGR)lpr_1).getName()));
            } else {
              stringList.addAll(this.getNext(lpr_1));
            }
          } else {
            stringList.add(i_1.getName());
          }
        }
      } else {
        if ((lp instanceof APRO)) {
          EList<InputPort> _ip_2 = ((APRO)lp).getIp();
          for (final InputPort i_2 : _ip_2) {
            OutputPort _outputport_2 = i_2.getOutputport();
            boolean _tripleNotEquals_2 = (_outputport_2 != null);
            if (_tripleNotEquals_2) {
              stringList.add(i_2.getOutputport().getName());
              Pattern lpr_2 = Helpers.getPattern(i_2.getOutputport());
              if ((lpr_2 instanceof MAGR)) {
                AGGR la_2 = Helpers.getAGGR(i_2.getOutputport());
                stringList.addAll(this.getNext(la_2, ((MAGR)lpr_2).getName()));
              } else {
                stringList.addAll(this.getNext(lpr_2));
              }
            } else {
              stringList.add(i_2.getName());
            }
          }
        } else {
          if ((lp instanceof MAGR)) {
            EList<AGGR> _aggr = ((MAGR)lp).getAggr();
            for (final AGGR i_3 : _aggr) {
              EList<InputPort> _ip_3 = i_3.getIp();
              for (final InputPort j : _ip_3) {
                OutputPort _outputport_3 = j.getOutputport();
                boolean _tripleNotEquals_3 = (_outputport_3 != null);
                if (_tripleNotEquals_3) {
                  stringList.add(j.getOutputport().getName());
                  Pattern lpr_3 = Helpers.getPattern(j.getOutputport());
                  if ((lpr_3 instanceof MAGR)) {
                    AGGR la_3 = Helpers.getAGGR(j.getOutputport());
                    stringList.addAll(this.getNext(la_3, ((MAGR)lpr_3).getName()));
                  } else {
                    stringList.addAll(this.getNext(lpr_3));
                  }
                } else {
                  stringList.add(j.getName());
                }
              }
            }
          } else {
            if ((lp instanceof CONT)) {
              EList<InputPort> _ip_4 = ((CONT)lp).getIp();
              for (final InputPort i_4 : _ip_4) {
                OutputPort _outputport_4 = i_4.getOutputport();
                boolean _tripleNotEquals_4 = (_outputport_4 != null);
                if (_tripleNotEquals_4) {
                  stringList.add(i_4.getOutputport().getName());
                  Pattern lpr_4 = Helpers.getPattern(i_4.getOutputport());
                  if ((lpr_4 instanceof MAGR)) {
                    AGGR la_4 = Helpers.getAGGR(i_4.getOutputport());
                    stringList.addAll(this.getNext(la_4, ((MAGR)lpr_4).getName()));
                  } else {
                    stringList.addAll(this.getNext(lpr_4));
                  }
                } else {
                  stringList.add(i_4.getName());
                }
              }
              EObject tmp = ((CONT)lp).getIpp();
              if ((tmp instanceof InputWSMPort)) {
                stringList.add(((InputWSMPort)tmp).getOutputwsmport().getName());
                Pattern lpr_5 = Helpers.getPattern(((InputWSMPort)tmp).getOutputwsmport());
                stringList.addAll(this.getNext(lpr_5));
              }
            } else {
              if ((lp instanceof EPROD)) {
                EList<InputPort> _ip_5 = ((EPROD)lp).getIp();
                for (final InputPort i_5 : _ip_5) {
                  OutputPort _outputport_5 = i_5.getOutputport();
                  boolean _tripleNotEquals_5 = (_outputport_5 != null);
                  if (_tripleNotEquals_5) {
                    stringList.add(i_5.getOutputport().getName());
                    Pattern lpr_6 = Helpers.getPattern(i_5.getOutputport());
                    if ((lpr_6 instanceof MAGR)) {
                      AGGR la_5 = Helpers.getAGGR(i_5.getOutputport());
                      stringList.addAll(this.getNext(la_5, ((MAGR)lpr_6).getName()));
                    } else {
                      stringList.addAll(this.getNext(lpr_6));
                    }
                  } else {
                    stringList.add(i_5.getName());
                  }
                }
              } else {
                if ((lp instanceof TRAN)) {
                  OutputPort _outputport_6 = ((TRAN)lp).getIp().getOutputport();
                  boolean _tripleNotEquals_6 = (_outputport_6 != null);
                  if (_tripleNotEquals_6) {
                    stringList.add(((TRAN)lp).getIp().getOutputport().getName());
                    Pattern lpr_7 = Helpers.getPattern(((TRAN)lp).getIp().getOutputport());
                    if ((lpr_7 instanceof MAGR)) {
                      AGGR la_6 = Helpers.getAGGR(((TRAN)lp).getIp().getOutputport());
                      stringList.addAll(this.getNext(la_6, ((MAGR)lpr_7).getName()));
                    } else {
                      stringList.addAll(this.getNext(lpr_7));
                    }
                  } else {
                    stringList.add(((TRAN)lp).getIp().getName());
                  }
                } else {
                  if ((lp instanceof COMF)) {
                    OutputPort _outputport_7 = ((COMF)lp).getIp().getOutputport();
                    boolean _tripleNotEquals_7 = (_outputport_7 != null);
                    if (_tripleNotEquals_7) {
                      stringList.add(((COMF)lp).getIp().getOutputport().getName());
                      Pattern lpr_8 = Helpers.getPattern(((COMF)lp).getIp().getOutputport());
                      if ((lpr_8 instanceof MAGR)) {
                        AGGR la_7 = Helpers.getAGGR(((COMF)lp).getIp().getOutputport());
                        stringList.addAll(this.getNext(la_7, ((MAGR)lpr_8).getName()));
                      } else {
                        stringList.addAll(this.getNext(lpr_8));
                      }
                    } else {
                      stringList.add(((COMF)lp).getIp().getOutputport().getName());
                    }
                    stringList.add(((COMF)lp).getIcp().getOutputcport().getName());
                    Pattern lpr_9 = Helpers.getPattern(((COMF)lp).getIcp().getOutputcport());
                    stringList.addAll(this.getNext(lpr_9));
                  } else {
                    if ((lp instanceof PTCC)) {
                      EList<InputPort> _ip_6 = ((PTCC)lp).getIp();
                      for (final InputPort i_6 : _ip_6) {
                        OutputPort _outputport_8 = i_6.getOutputport();
                        boolean _tripleNotEquals_8 = (_outputport_8 != null);
                        if (_tripleNotEquals_8) {
                          stringList.add(i_6.getOutputport().getName());
                          Pattern lpr_10 = Helpers.getPattern(i_6.getOutputport());
                          if ((lpr_10 instanceof MAGR)) {
                            AGGR la_8 = Helpers.getAGGR(i_6.getOutputport());
                            stringList.addAll(this.getNext(la_8, ((MAGR)lpr_10).getName()));
                          } else {
                            stringList.addAll(this.getNext(lpr_10));
                          }
                        } else {
                          stringList.add(i_6.getName());
                        }
                      }
                      EObject tmp_1 = ((PTCC)lp).getIpp();
                      if ((tmp_1 instanceof InputWSMPort)) {
                        stringList.add(((InputWSMPort)tmp_1).getOutputwsmport().getName());
                        Pattern lpr_11 = Helpers.getPattern(((InputWSMPort)tmp_1).getOutputwsmport());
                        stringList.addAll(this.getNext(lpr_11));
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    this.IS_RESOLVED_MAP.put(lp, Boolean.valueOf(true));
    return stringList;
  }

  public List<String> getNext(final AGGR a, final String pname) {
    List<String> stringList = new ArrayList<String>();
    stringList.add(pname);
    EList<InputPort> _ip = a.getIp();
    for (final InputPort i : _ip) {
      OutputPort _outputport = i.getOutputport();
      boolean _tripleNotEquals = (_outputport != null);
      if (_tripleNotEquals) {
        stringList.add(i.getOutputport().getName());
        Pattern lpr = Helpers.getPattern(i.getOutputport());
        if ((lpr instanceof MAGR)) {
          AGGR la = Helpers.getAGGR(i.getOutputport());
          stringList.addAll(this.getNext(la, ((MAGR)lpr).getName()));
        } else {
          stringList.addAll(this.getNext(lpr));
        }
      } else {
        stringList.add(i.getName());
      }
    }
    return stringList;
  }

  public void generate(final DVG dvg) {
    Set<Map.Entry<Pattern, Boolean>> _entrySet = this.IS_RESOLVED_MAP.entrySet();
    for (final Map.Entry<Pattern, Boolean> i : _entrySet) {
      i.setValue(Boolean.valueOf(false));
    }
    EList<Pattern> _pattern = dvg.getPattern();
    for (final Pattern i_1 : _pattern) {
      Boolean _get = this.IS_RESOLVED_MAP.get(i_1);
      boolean _not = (!(_get).booleanValue());
      if (_not) {
        this.resolveNext(i_1);
      }
    }
  }

  public String getInstanceName(final Pattern lp) {
    if ((lp instanceof INIT)) {
      int instanceCounter = this.solutionInitInstances.get(((INIT)lp).getAinip()).size();
      String name = ((INIT)lp).getAinip().getName();
      String _string = Integer.valueOf(instanceCounter).toString();
      String _plus = ((name + "_") + _string);
      name = _plus;
      return name;
    }
    return null;
  }

  public StringBuilder resolveNext(final Pattern lp) {
    StringBuilder _xblockexpression = null;
    {
      List<DVGPort> inputSet = new ArrayList<DVGPort>();
      List<List<DVGPort>> inputSetAg = new ArrayList<List<DVGPort>>();
      List<AbstractInputPort> inputSetInputs = new ArrayList<AbstractInputPort>();
      List<List<AbstractMap.SimpleEntry<AbstractOutputPort, String>>> allocInputSet = new ArrayList<List<AbstractMap.SimpleEntry<AbstractOutputPort, String>>>();
      List<Boolean> isAlloc = new ArrayList<Boolean>();
      if ((lp instanceof INIT)) {
        Interface _interface = ((INIT)lp).getAinip().getInterface();
        boolean _tripleEquals = (_interface == null);
        if (_tripleEquals) {
          this.INITIALIZATION_CODE.append(Leafs.generateLeaf(((INIT)lp).getAinip()));
        } else {
          if (((((INIT)lp).getAinip().getInterface() != null) && Objects.equal(((INIT)lp).getAinip().getInterface(), Interface.INTERNAL))) {
            this.INITIALIZATION_CODE.append(Leafs.generateLeaf(((INIT)lp).getAinip()));
          } else {
            if (((((INIT)lp).getAinip().getInterface() != null) && Objects.equal(((INIT)lp).getAinip().getInterface(), Interface.EXTERNAL))) {
              String res = "";
              boolean _isComplexDo = Helpers.isComplexDo(((INIT)lp).getAinip().getVe());
              if (_isComplexDo) {
                String _res = res;
                CharSequence _generateLeafValuesComplexTcl = Leafs.generateLeafValuesComplexTcl(((INIT)lp).getAinip().getName());
                res = (_res + _generateLeafValuesComplexTcl);
              } else {
                String _res_1 = res;
                CharSequence _generateLeafValuesTcl = Leafs.generateLeafValuesTcl(((INIT)lp).getAinip().getName());
                res = (_res_1 + _generateLeafValuesTcl);
              }
              this.INITIALIZATION_CODE.append(res);
            }
          }
        }
        this.addVariationPoints(((INIT)lp));
      } else {
        if ((lp instanceof RPRO)) {
          EList<InputPort> _ip = ((RPRO)lp).getIp();
          for (final InputPort i : _ip) {
            {
              inputSetInputs.add(i);
              inputSet.add(i.getOutputport());
              Pattern lpr = Helpers.getPattern(i.getOutputport());
              boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
              boolean _not = (!_containsKey);
              if (_not) {
                this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                this.resolveNext(lpr);
              } else {
                Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                boolean _not_1 = (!(_get).booleanValue());
                if (_not_1) {
                  this.resolveNext(lpr);
                }
              }
            }
          }
        } else {
          if ((lp instanceof SAPRO)) {
            EList<InputPort> _ip_1 = ((SAPRO)lp).getIp();
            for (final InputPort i_1 : _ip_1) {
              {
                inputSetInputs.add(i_1);
                inputSet.add(i_1.getOutputport());
                Pattern lpr = Helpers.getPattern(i_1.getOutputport());
                boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
                boolean _not = (!_containsKey);
                if (_not) {
                  this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                  this.resolveNext(lpr);
                } else {
                  Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                  boolean _not_1 = (!(_get).booleanValue());
                  if (_not_1) {
                    this.resolveNext(lpr);
                  }
                }
              }
            }
          } else {
            if ((lp instanceof APRO)) {
              EList<InputPort> _ip_2 = ((APRO)lp).getIp();
              for (final InputPort i_2 : _ip_2) {
                {
                  Pattern lpr = Helpers.getPattern(i_2.getOutputport());
                  inputSetInputs.add(i_2);
                  if ((lpr instanceof DMAGR)) {
                    this.handleDMAGRDep(lp, i_2, allocInputSet, isAlloc);
                  } else {
                    inputSet.add(i_2.getOutputport());
                    isAlloc.add(Boolean.valueOf(false));
                    boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
                    boolean _not = (!_containsKey);
                    if (_not) {
                      this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                      this.resolveNext(lpr);
                    } else {
                      Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                      boolean _not_1 = (!(_get).booleanValue());
                      if (_not_1) {
                        this.resolveNext(lpr);
                      }
                    }
                  }
                }
              }
            } else {
              if ((lp instanceof MAGR)) {
                Fork _f = ((MAGR)lp).getF();
                boolean _tripleNotEquals = (_f != null);
                if (_tripleNotEquals) {
                  Fork _f_1 = ((MAGR)lp).getF();
                  if ((_f_1 instanceof EquivalenceFork)) {
                    this.ACTIVE.put(((MAGR)lp).getName(), Integer.valueOf(((MAGR)lp).getAggr().get(0).getIp().size()));
                  } else {
                    Fork _f_2 = ((MAGR)lp).getF();
                    if ((_f_2 instanceof ConditionalFork)) {
                      this.PASSIVE_LOOKUP.put(((MAGR)lp).getName(), Integer.valueOf(((MAGR)lp).getAggr().get(0).getIp().size()));
                      String _name = ((MAGR)lp).getName();
                      int _size = ((MAGR)lp).getAggr().get(0).getIp().size();
                      AbstractMap.SimpleEntry<String, Integer> _simpleEntry = new AbstractMap.SimpleEntry<String, Integer>(_name, Integer.valueOf(_size));
                      this.PASSIVE_LOOKUP_LIST.add(_simpleEntry);
                    }
                  }
                } else {
                  Optional _o = ((MAGR)lp).getO();
                  boolean _tripleNotEquals_1 = (_o != null);
                  if (_tripleNotEquals_1) {
                    this.ACTIVE.put(((MAGR)lp).getName(), Integer.valueOf(((MAGR)lp).getAggr().get(0).getIp().size()));
                  } else {
                    OR _or = ((MAGR)lp).getOr();
                    boolean _tripleNotEquals_2 = (_or != null);
                    if (_tripleNotEquals_2) {
                      this.ACTIVE.put(((MAGR)lp).getName(), Integer.valueOf(((MAGR)lp).getAggr().get(0).getIp().size()));
                    } else {
                      XOR _x = ((MAGR)lp).getX();
                      boolean _tripleNotEquals_3 = (_x != null);
                      if (_tripleNotEquals_3) {
                        this.ACTIVE.put(((MAGR)lp).getName(), Integer.valueOf(((MAGR)lp).getAggr().get(0).getIp().size()));
                      }
                    }
                  }
                }
                EList<AGGR> _aggr = ((MAGR)lp).getAggr();
                for (final AGGR i_3 : _aggr) {
                  {
                    List<DVGPort> tmp = new ArrayList<DVGPort>();
                    EList<InputPort> _ip_3 = i_3.getIp();
                    for (final InputPort j : _ip_3) {
                      {
                        inputSetInputs.add(j);
                        tmp.add(j.getOutputport());
                        Pattern lpr = Helpers.getPattern(j.getOutputport());
                        boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
                        boolean _not = (!_containsKey);
                        if (_not) {
                          this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                          this.resolveNext(lpr);
                        } else {
                          Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                          boolean _not_1 = (!(_get).booleanValue());
                          if (_not_1) {
                            this.resolveNext(lpr);
                          }
                        }
                      }
                    }
                    inputSetAg.add(tmp);
                  }
                }
              } else {
                if ((lp instanceof DMAGR)) {
                } else {
                  if ((lp instanceof CONT)) {
                    EList<InputPort> _ip_3 = ((CONT)lp).getIp();
                    for (final InputPort i_4 : _ip_3) {
                      {
                        inputSetInputs.add(i_4);
                        inputSet.add(i_4.getOutputport());
                        Pattern lpr = Helpers.getPattern(i_4.getOutputport());
                        boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
                        boolean _not = (!_containsKey);
                        if (_not) {
                          this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                          this.resolveNext(lpr);
                        } else {
                          Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                          boolean _not_1 = (!(_get).booleanValue());
                          if (_not_1) {
                            this.resolveNext(lpr);
                          }
                        }
                      }
                    }
                    EObject tmp = ((CONT)lp).getIpp();
                    if ((tmp instanceof InputWSMPort)) {
                      inputSetInputs.add(((AbstractInputPort)tmp));
                      inputSet.add(((InputWSMPort)tmp).getOutputwsmport());
                      Pattern lpr = Helpers.getPattern(((InputWSMPort)tmp).getOutputwsmport());
                      boolean _containsKey = this.IS_RESOLVED_MAP.containsKey(lpr);
                      boolean _not = (!_containsKey);
                      if (_not) {
                        this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
                        this.resolveNext(lpr);
                      } else {
                        Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
                        boolean _not_1 = (!(_get).booleanValue());
                        if (_not_1) {
                          this.resolveNext(lpr);
                        }
                      }
                    }
                  } else {
                    if ((lp instanceof EPROD)) {
                      EList<InputPort> _ip_4 = ((EPROD)lp).getIp();
                      for (final InputPort i_5 : _ip_4) {
                        {
                          inputSetInputs.add(i_5);
                          inputSet.add(i_5.getOutputport());
                          Pattern lpr_1 = Helpers.getPattern(i_5.getOutputport());
                          boolean _containsKey_1 = this.IS_RESOLVED_MAP.containsKey(lpr_1);
                          boolean _not_2 = (!_containsKey_1);
                          if (_not_2) {
                            this.IS_RESOLVED_MAP.put(lpr_1, Boolean.valueOf(false));
                            this.resolveNext(lpr_1);
                          } else {
                            Boolean _get_1 = this.IS_RESOLVED_MAP.get(lpr_1);
                            boolean _not_3 = (!(_get_1).booleanValue());
                            if (_not_3) {
                              this.resolveNext(lpr_1);
                            }
                          }
                        }
                      }
                    } else {
                      if ((lp instanceof TRAN)) {
                        inputSetInputs.add(((TRAN)lp).getIp());
                        inputSet.add(((TRAN)lp).getIp().getOutputport());
                        Pattern lpr_1 = Helpers.getPattern(((TRAN)lp).getIp().getOutputport());
                        boolean _containsKey_1 = this.IS_RESOLVED_MAP.containsKey(lpr_1);
                        boolean _not_2 = (!_containsKey_1);
                        if (_not_2) {
                          this.IS_RESOLVED_MAP.put(lpr_1, Boolean.valueOf(false));
                          this.resolveNext(lpr_1);
                        } else {
                          Boolean _get_1 = this.IS_RESOLVED_MAP.get(lpr_1);
                          boolean _not_3 = (!(_get_1).booleanValue());
                          if (_not_3) {
                            this.resolveNext(lpr_1);
                          }
                        }
                      } else {
                        if ((lp instanceof COMF)) {
                          inputSetInputs.add(((COMF)lp).getIp());
                          Pattern lpr_2 = Helpers.getPattern(((COMF)lp).getIp().getOutputport());
                          if ((lpr_2 instanceof DMAGR)) {
                            this.handleDMAGRDep(lp, ((COMF)lp).getIp(), allocInputSet, isAlloc);
                            inputSetInputs.add(((COMF)lp).getIcp());
                            inputSet.add(((COMF)lp).getIcp().getOutputcport());
                            isAlloc.add(Boolean.valueOf(false));
                            lpr_2 = Helpers.getPattern(((COMF)lp).getIcp().getOutputcport());
                            boolean _containsKey_2 = this.IS_RESOLVED_MAP.containsKey(lpr_2);
                            boolean _not_4 = (!_containsKey_2);
                            if (_not_4) {
                              this.IS_RESOLVED_MAP.put(lpr_2, Boolean.valueOf(false));
                              this.resolveNext(lpr_2);
                            } else {
                              Boolean _get_2 = this.IS_RESOLVED_MAP.get(lpr_2);
                              boolean _not_5 = (!(_get_2).booleanValue());
                              if (_not_5) {
                                this.resolveNext(lpr_2);
                              }
                            }
                          } else {
                            inputSet.add(((COMF)lp).getIp().getOutputport());
                            isAlloc.add(Boolean.valueOf(false));
                            boolean _containsKey_3 = this.IS_RESOLVED_MAP.containsKey(lpr_2);
                            boolean _not_6 = (!_containsKey_3);
                            if (_not_6) {
                              this.IS_RESOLVED_MAP.put(lpr_2, Boolean.valueOf(false));
                              this.resolveNext(lpr_2);
                            } else {
                              Boolean _get_3 = this.IS_RESOLVED_MAP.get(lpr_2);
                              boolean _not_7 = (!(_get_3).booleanValue());
                              if (_not_7) {
                                this.resolveNext(lpr_2);
                              }
                            }
                            inputSetInputs.add(((COMF)lp).getIcp());
                            inputSet.add(((COMF)lp).getIcp().getOutputcport());
                            lpr_2 = Helpers.getPattern(((COMF)lp).getIcp().getOutputcport());
                            boolean _containsKey_4 = this.IS_RESOLVED_MAP.containsKey(lpr_2);
                            boolean _not_8 = (!_containsKey_4);
                            if (_not_8) {
                              this.IS_RESOLVED_MAP.put(lpr_2, Boolean.valueOf(false));
                              this.resolveNext(lpr_2);
                            } else {
                              Boolean _get_4 = this.IS_RESOLVED_MAP.get(lpr_2);
                              boolean _not_9 = (!(_get_4).booleanValue());
                              if (_not_9) {
                                this.resolveNext(lpr_2);
                              }
                            }
                          }
                        } else {
                          if ((lp instanceof PTCC)) {
                            EList<InputPort> _ip_5 = ((PTCC)lp).getIp();
                            for (final InputPort i_6 : _ip_5) {
                              {
                                inputSetInputs.add(i_6);
                                inputSet.add(i_6.getOutputport());
                                Pattern lpr_3 = Helpers.getPattern(i_6.getOutputport());
                                boolean _containsKey_5 = this.IS_RESOLVED_MAP.containsKey(lpr_3);
                                boolean _not_10 = (!_containsKey_5);
                                if (_not_10) {
                                  this.IS_RESOLVED_MAP.put(lpr_3, Boolean.valueOf(false));
                                  this.resolveNext(lpr_3);
                                } else {
                                  Boolean _get_5 = this.IS_RESOLVED_MAP.get(lpr_3);
                                  boolean _not_11 = (!(_get_5).booleanValue());
                                  if (_not_11) {
                                    this.resolveNext(lpr_3);
                                  }
                                }
                              }
                            }
                            EObject tmp_1 = ((PTCC)lp).getIpp();
                            if ((tmp_1 instanceof InputWSMPort)) {
                              inputSetInputs.add(((AbstractInputPort)tmp_1));
                              inputSet.add(((InputWSMPort)tmp_1).getOutputwsmport());
                              Pattern lpr_3 = Helpers.getPattern(((InputWSMPort)tmp_1).getOutputwsmport());
                              boolean _containsKey_5 = this.IS_RESOLVED_MAP.containsKey(lpr_3);
                              boolean _not_10 = (!_containsKey_5);
                              if (_not_10) {
                                this.IS_RESOLVED_MAP.put(lpr_3, Boolean.valueOf(false));
                                this.resolveNext(lpr_3);
                              } else {
                                Boolean _get_5 = this.IS_RESOLVED_MAP.get(lpr_3);
                                boolean _not_11 = (!(_get_5).booleanValue());
                                if (_not_11) {
                                  this.resolveNext(lpr_3);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      this.resolve(lp, inputSetInputs);
      this.IS_RESOLVED_MAP.put(lp, Boolean.valueOf(true));
      StringBuilder _xifexpression = null;
      if ((lp instanceof MAGR)) {
        _xifexpression = this.CALL_SEQUENCE_CODE.append(JavaFunctions.generateCallSequenceCodeAg(((MAGR)lp).getName(), inputSetAg));
      } else {
        StringBuilder _xifexpression_1 = null;
        if (((!(lp instanceof INIT)) && (!(lp instanceof DMAGR)))) {
          _xifexpression_1 = this.CALL_SEQUENCE_CODE.append(JavaFunctions.generateCallSequenceCode(lp.getName(), inputSet, allocInputSet, isAlloc));
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }

  public void handleDMAGRDep(final Pattern lp, final InputPort i, final List<List<AbstractMap.SimpleEntry<AbstractOutputPort, String>>> allocInputSet, final List<Boolean> isAlloc) {
    List<AbstractMap.SimpleEntry<AbstractOutputPort, String>> ais = this.getMatchingSolutionOutputForEachAllocation(lp, i);
    String _name = lp.getName();
    String _plus = ("Depends on DMAGR: " + _name);
    InputOutput.<String>println(_plus);
    for (final AbstractMap.SimpleEntry<AbstractOutputPort, String> f : ais) {
      InputOutput.<String>println(f.getKey().getName());
    }
    allocInputSet.add(ais);
    isAlloc.add(Boolean.valueOf(true));
    for (final AbstractMap.SimpleEntry<AbstractOutputPort, String> a : ais) {
      {
        Pattern lpr = Helpers.getPattern(a.getKey());
        if ((lpr instanceof INIT)) {
          boolean _containsKey = this.solutionInitInstances.containsKey(a.getKey());
          boolean _not = (!_containsKey);
          if (_not) {
            List<Pattern> tmp = new ArrayList<Pattern>();
            tmp.add(lp);
            this.solutionInitInstances.put(a.getKey(), tmp);
            String n = this.getInstanceName(lpr);
            a.setValue(n);
            if (((((INIT)lpr).getAinip().getInterface() == null) || ((((INIT)lpr).getAinip().getInterface() != null) && Objects.equal(((INIT)lpr).getAinip().getInterface(), Interface.INTERNAL)))) {
              if (this.mom) {
                this.INITIALIZATION_CODE.append(Leafs.generateLeaf(((INIT)lpr).getAinip(), n, (this.UNIQUE_RESOURCE_ID.get(((INIT)lpr).getAinip())).intValue()));
              } else {
                this.INITIALIZATION_CODE.append(Leafs.generateLeaf(((INIT)lpr).getAinip(), n));
              }
            }
          } else {
            List<Pattern> tmp_1 = this.solutionInitInstances.get(a.getKey());
            boolean _contains = tmp_1.contains(lp);
            boolean _not_1 = (!_contains);
            if (_not_1) {
              tmp_1.add(lp);
              this.solutionInitInstances.put(a.getKey(), tmp_1);
              String n_1 = this.getInstanceName(lpr);
              a.setValue(n_1);
              if (((((INIT)lpr).getAinip().getInterface() == null) || ((((INIT)lpr).getAinip().getInterface() != null) && Objects.equal(((INIT)lpr).getAinip().getInterface(), Interface.INTERNAL)))) {
                if (this.mom) {
                  this.INITIALIZATION_CODE.append(Leafs.generateLeaf(((INIT)lpr).getAinip(), n_1, (this.UNIQUE_RESOURCE_ID.get(((INIT)lpr).getAinip())).intValue()));
                } else {
                  this.INITIALIZATION_CODE.append(Leafs.generateLeaf(((INIT)lpr).getAinip(), n_1));
                }
              }
            } else {
              String n_2 = this.getInstanceName(lpr);
              a.setValue(n_2);
            }
          }
          this.addVariationPoints(((INIT)lpr));
        } else {
          boolean _containsKey_1 = this.IS_RESOLVED_MAP.containsKey(lpr);
          boolean _not_2 = (!_containsKey_1);
          if (_not_2) {
            this.IS_RESOLVED_MAP.put(lpr, Boolean.valueOf(false));
            this.resolveNext(lpr);
          } else {
            Boolean _get = this.IS_RESOLVED_MAP.get(lpr);
            boolean _not_3 = (!(_get).booleanValue());
            if (_not_3) {
              this.resolveNext(lpr);
            }
          }
        }
      }
    }
  }

  public List<AbstractMap.SimpleEntry<AbstractOutputPort, String>> getMatchingSolutionOutputForEachAllocation(final Pattern p, final InputPort ip) {
    List<AbstractMap.SimpleEntry<AbstractOutputPort, String>> solutionOutputAllocations = new ArrayList<AbstractMap.SimpleEntry<AbstractOutputPort, String>>();
    for (int j = 0; (j < this.allocationsListListNoDuplicates.size()); j++) {
      {
        int solution = (-1);
        int _size = this.allocationsListListNoDuplicates.get(0).size();
        boolean _equals = (_size == 1);
        if (_equals) {
          solution = (this.allocationsListListNoDuplicates.get(j).get(0)).intValue();
        } else {
          solution = (this.allocationsListListNoDuplicates.get(j).get(Helpers.getResGroupOfPattern(p))).intValue();
        }
        List<Pattern> solutionPatterns = this.solutionDVGPattern.get(Integer.valueOf(solution));
        for (final Pattern m : solutionPatterns) {
          VariabilityEntity _ve = ip.getOutputport().getVe();
          VariabilityEntity _veFromPattern = Helpers.getVeFromPattern(m);
          boolean _equals_1 = Objects.equal(_ve, _veFromPattern);
          if (_equals_1) {
            if ((m instanceof INIT)) {
              AbstractInitPort _ainip = ((INIT)m).getAinip();
              String _name = ((INIT)m).getAinip().getName();
              AbstractMap.SimpleEntry<AbstractOutputPort, String> _simpleEntry = new AbstractMap.SimpleEntry<AbstractOutputPort, String>(_ainip, _name);
              solutionOutputAllocations.add(_simpleEntry);
              String _name_1 = ((INIT)m).getAinip().getName();
              String _plus = ("m.ainip: " + _name_1);
              InputOutput.<String>println(_plus);
              this.UNIQUE_RESOURCE_ID.put(((INIT)m).getAinip(), Integer.valueOf(solution));
            }
          }
        }
      }
    }
    return solutionOutputAllocations;
  }

  public StringBuilder resolve(final Pattern lp, final List<AbstractInputPort> inputSet) {
    StringBuilder _xifexpression = null;
    if ((lp instanceof COMF)) {
      StringBuilder _xblockexpression = null;
      {
        COMFPattern comfp = new COMFPattern(((COMF)lp));
        comfp.generate();
        this.LOCAL_RESOLUTION_CODE.append(comfp.getCode());
        _xblockexpression = this.LOCAL_RESOLUTION_CODE.append("\n\n");
      }
      _xifexpression = _xblockexpression;
    } else {
      StringBuilder _xifexpression_1 = null;
      if ((lp instanceof RPRO)) {
        StringBuilder _xblockexpression_1 = null;
        {
          RPROPattern rprop = null;
          StringBuilder _xifexpression_2 = null;
          if (((((RPRO)lp).getOpp() != null) && (((RPRO)lp).getOp() != null))) {
            System.out.println("ERROR: RPRO can not have both a OutputNode and a OutputPSNode!");
          } else {
            StringBuilder _xifexpression_3 = null;
            if (((((RPRO)lp).getOpp() != null) && (((RPRO)lp).getOp() == null))) {
              StringBuilder _xblockexpression_2 = null;
              {
                RPROPattern _rPROPattern = new RPROPattern(((RPRO)lp), inputSet, true);
                rprop = _rPROPattern;
                rprop.generate();
                this.LOCAL_RESOLUTION_CODE.append(rprop.getCode());
                _xblockexpression_2 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
              }
              _xifexpression_3 = _xblockexpression_2;
            } else {
              StringBuilder _xifexpression_4 = null;
              if (((((RPRO)lp).getOpp() == null) && (((RPRO)lp).getOp() != null))) {
                StringBuilder _xblockexpression_3 = null;
                {
                  RPROPattern _rPROPattern = new RPROPattern(((RPRO)lp), inputSet, false);
                  rprop = _rPROPattern;
                  rprop.generate();
                  this.LOCAL_RESOLUTION_CODE.append(rprop.getCode());
                  _xblockexpression_3 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
                }
                _xifexpression_4 = _xblockexpression_3;
              } else {
                System.out.println("ERROR: RPRO has no OutputNode!");
              }
              _xifexpression_3 = _xifexpression_4;
            }
            _xifexpression_2 = _xifexpression_3;
          }
          _xblockexpression_1 = _xifexpression_2;
        }
        _xifexpression_1 = _xblockexpression_1;
      } else {
        StringBuilder _xifexpression_2 = null;
        if ((lp instanceof SAPRO)) {
          StringBuilder _xblockexpression_2 = null;
          {
            SAPROPattern saprop = new SAPROPattern(((SAPRO)lp), inputSet);
            saprop.generate();
            this.LOCAL_RESOLUTION_CODE.append(saprop.getCode());
            _xblockexpression_2 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
          }
          _xifexpression_2 = _xblockexpression_2;
        } else {
          StringBuilder _xifexpression_3 = null;
          if ((lp instanceof APRO)) {
            StringBuilder _xblockexpression_3 = null;
            {
              APROPattern aprop = new APROPattern(((APRO)lp), inputSet, true);
              aprop.generate();
              this.LOCAL_RESOLUTION_CODE.append(aprop.getCode());
              _xblockexpression_3 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
            }
            _xifexpression_3 = _xblockexpression_3;
          } else {
            StringBuilder _xifexpression_4 = null;
            if ((lp instanceof MAGR)) {
              StringBuilder _xblockexpression_4 = null;
              {
                MAGRPattern magrp = new MAGRPattern(((MAGR)lp));
                magrp.generate();
                this.LOCAL_RESOLUTION_CODE.append(magrp.getCode());
                _xblockexpression_4 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
              }
              _xifexpression_4 = _xblockexpression_4;
            } else {
              StringBuilder _xifexpression_5 = null;
              if ((lp instanceof TRAN)) {
                StringBuilder _xblockexpression_5 = null;
                {
                  TRANPattern tranp = new TRANPattern(((TRAN)lp));
                  tranp.generate();
                  this.LOCAL_RESOLUTION_CODE.append(tranp.getCode());
                  _xblockexpression_5 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
                }
                _xifexpression_5 = _xblockexpression_5;
              } else {
                StringBuilder _xifexpression_6 = null;
                if ((lp instanceof CONT)) {
                  StringBuilder _xblockexpression_6 = null;
                  {
                    CONTPattern contp = new CONTPattern(((CONT)lp));
                    contp.generate();
                    this.LOCAL_RESOLUTION_CODE.append(contp.getCode());
                    _xblockexpression_6 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
                  }
                  _xifexpression_6 = _xblockexpression_6;
                } else {
                  StringBuilder _xifexpression_7 = null;
                  if ((lp instanceof EPROD)) {
                    StringBuilder _xblockexpression_7 = null;
                    {
                      EPRODPattern eprop = new EPRODPattern(((EPROD)lp));
                      eprop.generate();
                      this.LOCAL_RESOLUTION_CODE.append(eprop.getCode());
                      _xblockexpression_7 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
                    }
                    _xifexpression_7 = _xblockexpression_7;
                  } else {
                    StringBuilder _xifexpression_8 = null;
                    if ((lp instanceof PTCC)) {
                      StringBuilder _xblockexpression_8 = null;
                      {
                        PTCCPattern ptccp = new PTCCPattern(((PTCC)lp));
                        ptccp.generate();
                        this.LOCAL_RESOLUTION_CODE.append(ptccp.getCode());
                        _xblockexpression_8 = this.LOCAL_RESOLUTION_CODE.append("\n\n");
                      }
                      _xifexpression_8 = _xblockexpression_8;
                    } else {
                      _xifexpression_8 = null;
                    }
                    _xifexpression_7 = _xifexpression_8;
                  }
                  _xifexpression_6 = _xifexpression_7;
                }
                _xifexpression_5 = _xifexpression_6;
              }
              _xifexpression_4 = _xifexpression_5;
            }
            _xifexpression_3 = _xifexpression_4;
          }
          _xifexpression_2 = _xifexpression_3;
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }

  public Object addVariationPoints(final INIT init) {
    Object _xifexpression = null;
    VT _vt = init.getAinip().getVt();
    boolean _equals = Objects.equal(_vt, VT.ACTIVE);
    if (_equals) {
      _xifexpression = this.ACTIVE.put(init.getAinip().getName(), Integer.valueOf(Helpers.getVSPInitSize(init.getAinip())));
    } else {
      Object _xifexpression_1 = null;
      VT _vt_1 = init.getAinip().getVt();
      boolean _equals_1 = Objects.equal(_vt_1, VT.CONSTANT);
      if (_equals_1) {
        _xifexpression_1 = this.CONSTANT.put(init.getAinip().getName(), Integer.valueOf(Helpers.getVSPInitSize(init.getAinip())));
      } else {
        boolean _xblockexpression = false;
        {
          this.PASSIVE_LOOKUP.put(init.getAinip().getName(), Integer.valueOf(Helpers.getVSPInitSize(init.getAinip())));
          String _name = init.getAinip().getName();
          int _vSPInitSize = Helpers.getVSPInitSize(init.getAinip());
          AbstractMap.SimpleEntry<String, Integer> _simpleEntry = new AbstractMap.SimpleEntry<String, Integer>(_name, Integer.valueOf(_vSPInitSize));
          _xblockexpression = this.PASSIVE_LOOKUP_LIST.add(_simpleEntry);
        }
        _xifexpression_1 = Boolean.valueOf(_xblockexpression);
      }
      _xifexpression = ((Object)_xifexpression_1);
    }
    return _xifexpression;
  }

  public CharSequence generateInitCode() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("void init() {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("this.NODE_COLLECTION = new HashMap<String, Node>();");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("List<Object> leafValues;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("List<List<Object>> leafValues_2;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("List<Map<String,Double>> leafValuesPsMapList;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Map<String,Double> leafValuesPsMap;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("NodeObject nodeObject;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("NodeObjectList nodeObjectList;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("NodePs nodePs;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("Random random;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("String[] dataFromFile;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append(this.INITIALIZATION_CODE, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }

  public CharSequence generateDVGSolverCode(final String dvgName, final String outputName) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _generateSolveCode = this.generateSolveCode(dvgName, outputName);
    _builder.append(_generateSolveCode);
    _builder.newLineIfNotEmpty();
    {
      if ((!this.mom)) {
        _builder.append("public class DVGSolver_");
        _builder.append(dvgName);
        _builder.append(" {");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("public static void main (String[] args) {");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("Solve solve = new Solve();");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("solve.init();");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("solve.solve();\t");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("}");
        _builder.newLine();
      }
    }
    return _builder;
  }

  public CharSequence generateSolveCode(final String dvgName, final String outputName) {
    StringConcatenation _builder = new StringConcatenation();
    {
      if ((!this.mom)) {
        _builder.append("class Solve {");
        _builder.newLine();
      } else {
        _builder.append("class ");
        _builder.append(dvgName);
        _builder.append(" {");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("Node getNode(String name) {");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("return NODE_COLLECTION.get(name);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("int getAllocations() {");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("return ");
        int _size = this.allocationsListListNoDuplicates.size();
        _builder.append(_size, "\t\t");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("\t");
    _builder.append("private Map<String, Node> NODE_COLLECTION;");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    CharSequence _generateGetCartesianProduct = JavaFunctions.generateGetCartesianProduct();
    _builder.append(_generateGetCartesianProduct, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    CharSequence _generateIsSAM = JavaFunctions.generateIsSAM();
    _builder.append(_generateIsSAM, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    CharSequence _generateIsValidCombinationIgnoreResource = JavaFunctions.generateIsValidCombinationIgnoreResource();
    _builder.append(_generateIsValidCombinationIgnoreResource, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    CharSequence _generateIsDominated = JavaFunctions.generateIsDominated();
    _builder.append(_generateIsDominated, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    CharSequence _generateMaxFunction = JavaFunctions.generateMaxFunction();
    _builder.append(_generateMaxFunction, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    CharSequence _generateMinFunction = JavaFunctions.generateMinFunction();
    _builder.append(_generateMinFunction, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    CharSequence _generateGetDataFromFile = JavaFunctions.generateGetDataFromFile();
    _builder.append(_generateGetDataFromFile, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append(this.LOCAL_RESOLUTION_CODE, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    CharSequence _generateInitCode = this.generateInitCode();
    _builder.append(_generateInitCode, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    {
      if ((!this.mom)) {
        _builder.append("\t");
        CharSequence _generateSolveCode = FinalEvaluation.generateSolveCode(outputName, this.finalOperationIsMax, this.CALL_SEQUENCE_CODE.toString(), this.ACTIVE, this.PASSIVE_LOOKUP, this.allocationsListListNoDuplicates.size());
        _builder.append(_generateSolveCode, "\t");
        _builder.newLineIfNotEmpty();
      } else {
        _builder.append("\t");
        _builder.append("Node solve(String name, int allocation) {");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("List<Node> params;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("List<List<Node>> params_2d;");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append(this.CALL_SEQUENCE_CODE, "\t\t");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("return this.NODE_COLLECTION.get(name);");
        _builder.newLine();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
}
